<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Install archlinux on Thinkbook14 G4+ ARA</title>
      <link href="/2022/09/20/Install-archlinux-on-Thinkbook14-G4-ARA/"/>
      <url>/2022/09/20/Install-archlinux-on-Thinkbook14-G4-ARA/</url>
      
        <content type="html"><![CDATA[<h2 id="0-前言">0 前言</h2><p>​新到的Thinkbook 14+ AMD 6800h 到手后迫不及待的试图安装双系统Win11+Archlinux</p><p>由于是新笔记本新CPU,在安装过程中出现了许多问题，特意记录一下。</p><h2 id="1-安装windows11">1. 安装windows11</h2><p>​出厂windows带了太多捆绑软件，包括但不限于联想管家等。本人选择重新安装</p><ol><li><p>使用<a href="https://rufus.ie/zh/">rufus</a>将windows11镜像烧录至U盘制作系统启动盘</p></li><li><p>启动阶段按<code>F12</code>（不需要按住<code>Fn</code>）进入启动选项，选择USB启动</p></li><li><p>windows安装一路点点点就好</p></li><li><p>安装驱动</p><p>由于windows镜像中不包含螃蟹无线网卡的驱动，在安装系统连接网络部分选择连接网线(这款笔记本居然有网口)。</p><p>当然也可以选择进入系统后安装驱动，<a href="https://think.lenovo.com.cn/support/driver/newdriversdownlist.aspx?categoryid=15260&amp;CODEName=thinkbook%2014%20G4+%20ARA&amp;SearchType=%200&amp;wherePage=%202">驱动</a>由联想官方提供，下载后直接安装即可</p></li><li><p>设置中文输入法</p><p>安装系统后发现微软拼音不出现候选词，而是直接敲回车后出现文字</p><p>解决方法：在键盘中其启用旧版微软拼音，具体操作流程如下</p><p>设置 -&gt; 时间和语言 -&gt; 语言&amp;区域 -&gt; Microsoft拼音 -&gt; 常规 -&gt; 兼容性 -&gt; 使用以前版本的微软拼音输入法</p></li></ol><h2 id="2-安装Archlinux">2. 安装Archlinux</h2><h3 id="2-1-系统安装">2.1 系统安装</h3><p>​Arch Linux系统安装过程整体上与<a href="https://arch.icekylin.online/prologue.html">archlinux 简明教材</a>一致，主要差别在于我使用<em>sysemd-boot</em>作为bootloader进行系统的引导，没有采用原文中较为臃肿的grub2进行系统引导。</p><p>需要改变的地方</p><ul><li><p>EFI分区挂载点不同</p><p>原文在<a href="https://arch.icekylin.online/rookie/basic-install.html#_8-%E6%8C%82%E8%BD%BD">基础安装 步骤8</a>将EFI分区挂载到系统镜像<code>/boot/efi</code>，要<strong>持续更新内核</strong>，建议将 ESP 挂载到 <code>/boot</code>，安装内核时会自动复制到<code>/boot</code>目录下. 如果没将 ESP 挂载到 <code>/boot</code>,需要手动将内核和 initramfs 复制到 ESP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mount -t btrfs -o subvol=/@,compress=zstd /dev/nvmexn1pn /mnt <span class="comment"># 挂载 / 目录</span></span><br><span class="line">mkdir /mnt/home <span class="comment"># 创建 /home 目录</span></span><br><span class="line">mount -t btrfs -o subvol=/@home,compress=zstd /dev/nvmexn1pn /mnt/home <span class="comment"># 挂载 /home 目录</span></span><br><span class="line">mkdir -p /mnt/boot <span class="comment"># 创建 /boot/efi 目录</span></span><br><span class="line">mount /dev/nvmexn1pn /mnt/boot <span class="comment"># 挂载 /boot/efi 目录</span></span><br><span class="line">swapon /dev/nvmexn1pn <span class="comment"># 挂载交换分区</span></span><br></pre></td></tr></table></figure></li><li><p>bootloader不同</p><p>原文在<a href="https://arch.icekylin.online/rookie/basic-install.html#_17-%E5%AE%89%E8%A3%85%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F">基础安装 步骤17</a>使用grub进行引导，由于不需要引导legacy或者其他的系统，我选择仅支持EFI启动的<em>systemd-boot</em>作为bootloader,具体步骤如下</p><ol><li><p>安装 <em>systemd-boot</em> EFI 启动管理器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">esp=/boot <span class="comment">#EFI分区挂载点</span></span><br><span class="line">bootctl --path=<span class="variable">$esp</span> install</span><br></pre></td></tr></table></figure></li><li><p>启动菜单配置</p><p>启动菜单文件位于<code>$esp/loader/loader.conf</code>,内容示例如下</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default  arch.conf</span><br><span class="line">timeout  4</span><br><span class="line">console-mode max</span><br><span class="line">editor   no</span><br></pre></td></tr></table></figure></li><li><p>增加启动选项</p><p>如果存在的话,bootctl 会自动为 “<strong>Windows Boot Manager (Windows 启动管理器)</strong>” (<code>\EFI\Microsoft\Boot\Bootmgfw.efi</code>), “<strong>EFI Shell</strong>” (<code>\shellx64.efi</code>) 和 “<strong>EFI Default Loader</strong>” (<code>\EFI\Boot\bootx64.efi</code>)增加启动选项. 但并不会为其他EFI应用程序创建启动选项,所以需要进行进一步设置. 如果你是和Windows 组成双重启动,建议禁用 <a href="https://wiki.archlinux.org/title/Dual_boot_with_Windows#Fast_Startup_and_hibernation">Windows 中的&quot;快速启动&quot;</a> 选项.</p><p>为archlinux增加启动选项，新建文件<code>$esp/loader/entries/arch.conf</code></p><p>内容如下,实际上就是kernel的启动参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title          Arch Linux</span><br><span class="line">linux          /vmlinuz-linux</span><br><span class="line">initrd   /amd-ucode.img</span><br><span class="line">initrd         /initramfs-linux.img</span><br><span class="line">options        root=PARTUUID=14420948-2cea-4de7-b042-40f67c618660 rw rootflags=subvol=@</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>​4. reboot 重启即可进入进入系统选择界面进入系统</p><h3 id="2-2-内置键盘失灵">2.2 内置键盘失灵</h3><p>​ThinkBook 14+/16+ 2022 锐龙版(AMD 锐龙 6000系列处理器 )由于其独特的IRQ设计，键盘无法兼容原版Linux内核，其反应为键盘像所有键同时按住而卡住，想要解决此问题，需要打上<a href="https://patchwork.kernel.org/project/linux-acpi/patch/20220712020058.90374-1-gch981213@gmail.com/">path</a>进行修改并重新编译Linux内核</p><p>这里采用ABS(Arch Build System)进行自定义kernel的编译(既然archlinux提供了好用的构建系统，为何不用呢:) )</p><p>主要步骤参考<a href="https://wiki.archlinux.org/title/Kernel/Arch_Build_System">Kernel/Arch Build System</a>,这里贴出自己的全部过程</p><ol><li><p>新建编译目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/build</span><br><span class="line"><span class="built_in">cd</span> ~/build</span><br></pre></td></tr></table></figure></li><li><p>安装asp 和base-devel</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S asp base-devel</span><br></pre></td></tr></table></figure></li><li><p>获取原始内核作为自己编译kernel的基础</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asp update linux <span class="comment">#由于网络问题我无法更新，不影响</span></span><br><span class="line">asp <span class="built_in">export</span> linux </span><br></pre></td></tr></table></figure><p>执行完后查看目录树应该是这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── linux</span><br><span class="line">    ├── config</span><br><span class="line">    ├── keys</span><br><span class="line">    │   └── pgp</span><br><span class="line">    │       ├── 647F28654894E3BD457199BE38DBBDC86092693E.asc</span><br><span class="line">    │       ├── A2FF3A36AAA56654109064AB19802F8B0D70FC30.asc</span><br><span class="line">    │       ├── ABAF11C65A2970B130ABE3C479BE3E4300411886.asc</span><br><span class="line">    │       └── C7E7849466FE2358343588377258734B41C31549.asc</span><br><span class="line">    └── PKGBUILD</span><br><span class="line"></span><br><span class="line">3 directories, 6 files</span><br></pre></td></tr></table></figure></li><li><p>下载需要打上的补丁，并放在与PKGBUILD同级目录下(改为patch后缀是因为ABS会自动为后缀为patch进行打补丁)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux</span><br><span class="line">wget https://patchwork.kernel.org/project/linux-acpi/patch/20220712020058.90374-1-gch981213@gmail.com/raw -O irq.patch <span class="comment">#下载diff文件并重命名为irq.patch(你也可以手动的下载diff文件)</span></span><br></pre></td></tr></table></figure></li><li><p>修改PKGBUILD文件</p><p>找到 <code>pkgbase</code> 修改为自定义软件包的名称</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkgbase=linux-test</span><br></pre></td></tr></table></figure><p>如果你想要直接替换原有的kernel,就可以不改。改了之后你要更新引导加载程序的配置文件，为新的内核和initramfs映像添加新的引导菜单项。</p><p>找到 <code>source</code>数组(18行左右)添加需要打的patch</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span>=(</span><br><span class="line">  <span class="string">&quot;<span class="variable">$_srcname</span>::git+https://github.com/archlinux/linux?signed#tag=<span class="variable">$_srctag</span>&quot;</span></span><br><span class="line">  irq.patch      <span class="comment"># 下载的补丁</span></span><br><span class="line">  config         <span class="comment"># the main kernel config file</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>为提高编译速度，可采用多线性并行编译，找到build(63行左右)，修改,可以自己选择线程数，还可以参考<a href="https://wiki.archlinux.org/title/Kernel/Arch_Build_System">Kernel/Arch Build System</a>的2.1避免创建文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">build</span></span>() &#123;</span><br><span class="line">   <span class="built_in">cd</span> <span class="variable">$_srcname</span></span><br><span class="line">   make all -j 16</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生成新校验和</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S pacman-contrib</span><br><span class="line">updpkgsums</span><br></pre></td></tr></table></figure></li><li><p>编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S pahole cpio xmlto python-sphinx python-sphinx_rtd_theme graphviz imagemagick texlive-latexextra <span class="comment">#安装必要依赖</span></span><br><span class="line">makepkg -s --skippgpcheck</span><br></pre></td></tr></table></figure></li><li><p>安装</p><p>编译完成后，<code>build/linux</code>文件夹中应有两个包，分别是内核和内核的头文件。进行安装(会在/boot下生成initramfs-linux-test和vmlinuz-linux-test)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -U linux-test-5.19.19-x86_64.pkg.tar.zst linux-custom-headers-5.8.12-x86_64.pkg.tar.zst</span><br></pre></td></tr></table></figure></li><li><p>为新的kernel配置启动项，见本文2.1中的增加启动选项</p></li><li><p>如果更换了内核，别忘了把之前在原来内核的软件重新装一遍，比如说桌面环境，我发现后续在新内核安装的程序在桌面应用程序找不到，重新安装一下kde就好了</p></li></ol><h3 id="2-3-网卡驱动">2.3 网卡驱动</h3><p>安装<a href="https://github.com/lwfinger/rtw8852be">8852be驱动</a></p><h3 id="2-4-无法播放声音">2.4 无法播放声音</h3><p>声卡驱动有，但是无法播放声音，缺失<a href="https://wiki.archlinux.org/title/Advanced_Linux_Sound_Architecture">alas固件</a></p><p>解决方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S sof-firmware alsa-ucm-conf</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> archlinux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Archlinux的包管理</title>
      <link href="/2022/09/03/Installation-on-Archlinux/"/>
      <url>/2022/09/03/Installation-on-Archlinux/</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>本文主要讲述archlinux常用的包管理和和对于app的安装方法。Archlinux包管理软件主要由Pacman以及AUR提供</p><h3 id="Pacman">Pacman</h3><p><a href="https://wiki.archlinux.org/title/pacman">Pacman</a>是Arch下官方的包管理软件，所有能够通过pacman下载安装，被纳入官方软件包列表的软件，都可以在<a href="https://archlinux.org/packages/">Arch Pachages</a>找到</p><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S &lt;package-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>更新/升级</p><p>更新AUR 软件包数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syy</span><br></pre></td></tr></table></figure><p>更新 AUR 软件包数据库并升级所有已安装的软件包(包括内核，小心风滚草😈️)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syyu</span><br></pre></td></tr></table></figure><p>其中 -S 表示 sync（同步），-y 表示从服务器下载新的软件包数据库，-yy 表示强制更新软件包数据库,-u 表示 upgrade（升级</p></li><li><p>卸载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman --Rscnu &lt;package-name&gt;</span><br></pre></td></tr></table></figure><p>-R 表示 Remove（移除），-s 删除不需要的依赖关系，-c（cascade）删除软件包及所有依赖于此的软件包，-n 表示 nosave（删除配置文件），-u 表示 unneeded</p></li><li><p>搜索</p><p>在线搜索</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Ss &lt;key-word&gt;</span><br></pre></td></tr></table></figure><p>本地搜索</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Qs &lt;key-word&gt; <span class="comment">#模糊匹配</span></span><br><span class="line">sudo pacman -Q &lt;package-name&gt; <span class="comment">#精确匹配 </span></span><br></pre></td></tr></table></figure></li><li><p>安装本地软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -U &lt;package-path&gt;</span><br></pre></td></tr></table></figure></li><li><p>清理无用软件包和缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Scc</span><br></pre></td></tr></table></figure></li></ol><h3 id="AUR">AUR</h3><p><a href="https://aur.archlinux.org/">Aur</a>是Arch 用户软件仓库，全称 Arch User-community Repository，AUR 是为用户而建、由用户主导的 Arch 软件仓库.</p><p>很多软件从git到编译到安装基本上都是相同的步骤，将这个过程打包成了一个脚本，我们只需要git下来这个脚本，即可完成软件的自动化安装</p><p>有时候AUR helper没有用就手动试试吧！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;aur repo&gt; <span class="comment"># 在拉取仓库</span></span><br><span class="line"><span class="built_in">cd</span> &lt;repo&gt;</span><br><span class="line">makepkg <span class="comment">#执行PKGBUILD脚本中的内容，生成一个文件名&quot;.xz&quot;结尾的二进制安装文件</span></span><br><span class="line">sudo pacman -U &lt;pkg&gt;</span><br></pre></td></tr></table></figure><h3 id="yay">yay</h3><p>yay是是一个用 Go 语言开发的 AUR Helper，具有高级依赖解决、PKGBUILD 下载、AUR 包名自动补全、移除生成依赖等功能，不需要用户手动进行<code>git clone</code>,<code>makepkg</code>,<code>pacman -U</code>等一系列操作，解放双手，类似于pacman</p><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S &lt;package-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>更新/升级</p><p>更新AUR 软件包数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Syy</span><br></pre></td></tr></table></figure><p>更新 AUR 软件包数据库并升级所有已安装的软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Syyu</span><br></pre></td></tr></table></figure><p>其中 -S 表示 sync（同步），-y 表示从服务器下载新的软件包数据库，-yy 表示强制更新软件包数据库,-u 表示 upgrade（升级</p></li><li><p>卸载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay --Rscnu &lt;package-name&gt;</span><br></pre></td></tr></table></figure><p>-R 表示 Remove（移除），-s 删除不需要的依赖关系，-c（cascade）删除软件包及所有依赖于此的软件包，-n 表示 nosave（删除配置文件），-u 表示 unneeded</p></li><li><p>搜索</p><p>在线搜索</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Ss &lt;key-word&gt;</span><br></pre></td></tr></table></figure><p>本地搜索</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -Qs &lt;key-word&gt; <span class="comment">#模糊匹配</span></span><br><span class="line">yay -Q &lt;package-name&gt; <span class="comment">#精确匹配 </span></span><br></pre></td></tr></table></figure></li><li><p>安装本地软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -U &lt;package-path&gt;</span><br></pre></td></tr></table></figure></li><li><p>清理无用软件包和缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Scc</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Archlinux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux统计文件或文件夹数量</title>
      <link href="/2022/08/16/Linux%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9%E6%95%B0%E9%87%8F/"/>
      <url>/2022/08/16/Linux%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>以下内容摘自<a href="http://noahsnail.com/2017/02/07/2017-02-07-Linux%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E7%9B%AE/">Tyan</a>,方便后续自己查询使用，感谢作者</p><h3 id="统计命令">统计命令</h3><p>Linux下有三个命令:<code>ls</code>,<code>grep</code>,<code>wc</code>。通过这三个命令的组合可实现统计目录下文件及文件夹的个数。</p><ol><li><p>统计当前目录下文件个数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l | grep &quot;^-&quot; | wc -l</span><br></pre></td></tr></table></figure></li><li><p>统计当前目录下文件的个数（包括子目录）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lR| grep &quot;^-&quot; | wc -l</span><br></pre></td></tr></table></figure></li><li><p>查看某目录下文件夹(目录)的个数（包括子目录）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lR | grep &quot;^d&quot; | wc -l</span><br></pre></td></tr></table></figure></li></ol><h3 id="命令详解">命令详解</h3><ul><li><p><code>ls -l</code></p><p>长列表输出该目录下文件信息(注意这里的文件是指目录、链接、设备文件等)，每一行对应一个文件或目录，<code>ls -lR</code>是列出所有文件，包括子目录。</p></li><li><p><code>grep &quot;^-&quot;</code></p><p>过滤<code>ls</code>的输出信息。正则表达式&quot;^-&quot;表示以<code>-</code>开头，因为统计文件夹改为<code>^d</code></p></li><li><p><code>wc -l</code></p><p>统计输出信息的行数，统计结果就是输出信息的行数，一行信息对应一个文件</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ priority_queue使用方法</title>
      <link href="/2022/02/26/priority-queue%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2022/02/26/priority-queue%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="优先队列priority-queue">优先队列priority_queue</h2><p>priority_queue是C++提供的优先队列，定义在头文件<code>&lt;queue&gt;</code>中，默认为最大优先队列<br>定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="keyword">class</span> <span class="title">Container</span> =</span> std::vector&lt;T&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Compare</span> =</span> std::less&lt;<span class="keyword">typename</span> Container::value_type&gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">priority_queue</span>;</span></span><br></pre></td></tr></table></figure><h3 id="模板形参">模板形参</h3><ul><li><p>T 存储元素类型</p></li><li><p>Container 用于存储元素的底层容器 如<code>std::vector&lt;T&gt;</code>,<code>std::vector&lt;std::vector&lt;T&gt; &gt;</code>,也就是容器的类型，</p></li><li><p>Compare 严格弱序的<a href="https://zh.cppreference.com/w/cpp/named_req/Compare"><em>比较</em> <em>(Compare)</em> </a>类型</p><p>对于自定义的compare函数，需提供严格弱序。对于比较函数，若返回true,说明left “小于” right<br>比较时，若要左操作数先于右操作数弹出，则应该返回false。(因为priority_queue总是返回**“最大”**的)，若要右操作数先弹出，则应该返回true</p></li></ul><h3 id="常用成员函数">常用成员函数</h3><table><thead><tr><th>成员函数</th><th>作用</th></tr></thead><tbody><tr><td>top</td><td>访问栈顶元素</td></tr><tr><td>empty</td><td>检查队列是否为空</td></tr><tr><td>size</td><td>返回容纳的元素数</td></tr><tr><td>push</td><td>插入元素，并对底层容器排序(自动完成)</td></tr><tr><td>pop</td><td>弹出队列第一个元素</td></tr><tr><td>emplace</td><td>原位构造元素并排序底层容器</td></tr><tr><td>swap</td><td>交换内容</td></tr></tbody></table><h3 id="使用">使用</h3><p>如不特殊</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">print_queue</span><span class="params">(T&amp; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; q.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单使用(大顶堆)</span></span><br><span class="line"><span class="comment">//这里默认使用了std::less&lt;T&gt;，这是一个仿函数类，重载了()操作符</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">constexpr bool operator()(const T &amp;lhs, const T &amp;rhs) const </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return lhs &lt; rhs; </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">std::priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>&#125;)&#123;</span><br><span class="line">q.<span class="built_in">push</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print_queue</span>(q);</span><br><span class="line"><span class="comment">//输出 9 8 7 6 5 4 3 2 1 0 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//小顶堆</span></span><br><span class="line">std::priority_queue&lt;<span class="keyword">int</span>, std::vector&lt;<span class="keyword">int</span>&gt;, std::greater&lt;<span class="keyword">int</span>&gt; &gt; q2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>&#125;)</span><br><span class="line">        q2.<span class="built_in">push</span>(n);</span><br><span class="line"><span class="built_in">print_queue</span>(q2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 0 1 2 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure><p>自定义比较函数</p><p>这里使用<code>std::vector&lt;std::vector&lt;int&gt;&gt;</code>作为底层容器，按二元组std::vector<int>第一个坐标从小到大排序，若相同则第二个坐标从小到大排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">print_queue</span><span class="params">(T&amp; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> temp = q.<span class="built_in">top</span>();</span><br><span class="line">        std::cout &lt;&lt; temp[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;temp[<span class="number">1</span>]&lt;&lt;std::endl;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义比较函数</span></span><br><span class="line"><span class="comment">//对于比较函数，若返回true,说明left是“小于” right的，</span></span><br><span class="line"><span class="comment">//priority_queue总是返回“最大”的，right就会优先被弹出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](std::vector&lt;<span class="keyword">int</span>&gt; left, std::vector&lt;<span class="keyword">int</span>&gt; right) &#123; </span><br><span class="line">        <span class="keyword">if</span>(left[<span class="number">0</span>] == right[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> left[<span class="number">0</span>] &gt; right[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> left[<span class="number">0</span>] &gt; right[<span class="number">0</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    std::priority_queue&lt;std::vector&lt;<span class="keyword">int</span>&gt;, std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q3</span>(cmp);</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; arr&#123;&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">5</span>,<span class="number">7</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;,&#123;<span class="number">9</span>,<span class="number">4</span>&#125;,&#123;<span class="number">4</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n :arr)&#123;</span><br><span class="line">        q3.<span class="built_in">push</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print_queue</span>(q3);;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 5</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">4 2</span></span><br><span class="line"><span class="comment">5 7</span></span><br><span class="line"><span class="comment">9 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> priority_queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11随机数</title>
      <link href="/2022/02/25/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
      <url>/2022/02/25/%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="c-11-伪随机数生成">c++11 伪随机数生成</h2><p>c++11 随机数库<code>&lt;random&gt;</code>提供生成随机数和伪随机数的类，<br>为生成伪随机数，主要包括两类</p><ol><li>均匀随机位生成器(URBG)，包含随机数引擎，它们是伪随机数生成器，是能够生成均匀分布整数序列的伪随机数</li><li>随机数分布(例如均匀分布，正态分布和泊松分布等)，它们将 URBG 的输出转换为各种统计分布<br>均匀随机位生成器和随机数分布相互使用。所有随机数引擎都可以指定地播种、序列化和反序列化，以用于可重复的模拟器</li></ol><h3 id="均匀随机位生成器">均匀随机位生成器</h3><p>均匀随机位生成器是<strong>函数对象(仿函数类)</strong>，它返回无符号整数值，并使得每个值在可能结果的范围中拥有（理想上）相等的被返回概率<br>主要有以下4种,</p><ol><li>随机数引擎<br>随机数引擎本质是一种算数算法，因此相同的种子多次调用产生的随机数是完全相同的<br>标准提供三种常用的引擎：linear_congruential_engine，mersenne_twister_engine 和 subtract_with_carry_engine。第一种是线性同余算法，第二种是梅森旋转算法，第三种带进位的线性同余算法。</li><li>随机数引擎适配器<br>随机数引擎适配器生成以另一随机数引擎为熵源的伪随机数</li><li>预定义随机数生成器<br>具体见<a href="!https://zh.cppreference.com/w/cpp/numeric/random">伪随机数生成</a><br>常用的有default_random_engine，mt19937，minstd_rand0等</li><li>非确定随机数生成器<br>使用硬件熵源的非确定随机数生成器<br>std::random_device</li></ol><p>使用方法<br>正常使用我们只需要使用预定义随机数生成器或者非确定随机数即可<br>随机数引擎接受一个整形参数当作种子，不提供的话，会使用默认值。如果想多次运行产生相同的随机数，可以使用一个确定的数作为种子。如果是想每次运行生成不一样的随机数，Linux 推荐使用 random_device 来产生一个随机数当作种子，windows 产生一个伪随机数作为种子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//选择某一种随机数生成器或者</span></span><br><span class="line">    std::random_device rd;  <span class="comment">//使用硬件熵源</span></span><br><span class="line">    <span class="comment">//将rd生成的非确定随机数作为随机数引擎的种子，当然自定义也行，相同的种子多次调用产生的随机数是完全相同</span></span><br><span class="line">    <span class="function">std::default_random_engine <span class="title">e</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="comment">//生成10个随机数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="built_in">e</span>()&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机数分布">随机数分布</h3><p>随机数分布后处理 URBG 的输出，以使得输出结果按照定义的统计概率密度函数分布<br>具体间<a href="https://zh.cppreference.com/w/cpp/numeric/random">随机数分布</a>中提供的类，常见的有均匀，正态等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 以随机值播种，若可能</span></span><br><span class="line">    std::random_device r;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 选择 1 与 6 间的随机数</span></span><br><span class="line">    <span class="function">std::default_random_engine <span class="title">e1</span><span class="params">(r())</span></span>;</span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; <span class="title">uniform_dist</span><span class="params">(<span class="number">1</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> mean = <span class="built_in">uniform_dist</span>(e1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Randomly-chosen mean: &quot;</span> &lt;&lt; mean &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值最可能接近平均</span></span><br><span class="line">    <span class="comment">// 标准差影响生成的值距离平均数的分散</span></span><br><span class="line">    std::random_device rd;</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">    std::normal_distribution&lt;&gt; d&#123;<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    std::map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hist&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;<span class="number">10000</span>; ++n) &#123;</span><br><span class="line">        ++hist[std::<span class="built_in">round</span>(<span class="built_in">d</span>(gen))];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : hist) &#123;</span><br><span class="line">        std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>)</span><br><span class="line">                  &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::<span class="built_in">string</span>(p.second/<span class="number">200</span>, <span class="string">&#x27;*&#x27;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++分割字符串</title>
      <link href="/2021/12/27/c-%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/12/27/c-%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="使用stringstream-getline">使用stringstream + getline</h3><p>使用<a href="https://www.cplusplus.com/reference/string/string/getline/">getline</a>进行分割<br>局限性，只能以单个字符作为分割线</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">istringstream <span class="title">ss</span><span class="params">(<span class="string">&quot;helloahelloahello&quot;</span>)</span></span>;</span><br><span class="line">    string word;</span><br><span class="line">    <span class="keyword">char</span> delim = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(ss,word,delim))&#123;</span><br><span class="line">        cout&lt;&lt;word&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="使用std-string-find">使用std::string::find</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for string delimiter</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span> <span class="params">(<span class="keyword">const</span> string&amp; s, <span class="keyword">const</span> string&amp; delimiter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> pos_start = <span class="number">0</span>, pos_end, delim_len = delimiter.<span class="built_in">length</span>();</span><br><span class="line">    string token;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pos_end = s.<span class="built_in">find</span> (delimiter, pos_start)) != string::npos) &#123;</span><br><span class="line">        token = s.<span class="built_in">substr</span> (pos_start, pos_end - pos_start);</span><br><span class="line">        pos_start = pos_end + delim_len;</span><br><span class="line">        <span class="keyword">if</span>(!token.<span class="built_in">empty</span>())</span><br><span class="line">        res.<span class="built_in">push_back</span> (token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos_start != s.<span class="built_in">size</span>())</span><br><span class="line">        res.<span class="built_in">push_back</span> (s.<span class="built_in">substr</span> (pos_start));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;adsf-+qwret-+nvfkbdsj-+orthdfjgh-+dfjrleih&quot;</span>;</span><br><span class="line">    string delimiter = <span class="string">&quot;-+&quot;</span>;</span><br><span class="line">    vector&lt;string&gt; v = <span class="built_in">split</span> (str, delimiter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : v) cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">adsf</span></span><br><span class="line"><span class="comment">qwret</span></span><br><span class="line"><span class="comment">nvfkbdsj</span></span><br><span class="line"><span class="comment">orthdfjgh</span></span><br><span class="line"><span class="comment">dfjrleih</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2021/12/23/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2021/12/23/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/tianyicui/pack">背包九讲</a></p></blockquote><h2 id="0-1背包">0-1背包</h2><h3 id="题目">题目</h3><p>有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>件物品和最多承载量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span>的背包。第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>件物品的重量是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其价值是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><h3 id="基本思路">基本思路</h3><p>作为最基础的背包问题，其特点是<strong>每件物品最多用一次</strong><br>用子问题定义状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F[i,w]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span></span></span></span>表示前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>件物品放入承载量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>的背包可获得的最大价值，则状态转移方程便是</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>w</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo>+</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F[i,w] = max(F[i-1,w],F[i-1,w-w_i]+v_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>其代表的意思是若只考虑第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>件物品的策略（放或不放），那么就可以转化为一个只和前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>件物品相关的问题。</p><ul><li>如果不放第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>件物品，问题就转化为“前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>件物品放入容量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>的背包中”，价值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F[i-1,w]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span></span></span></span>；</li><li>如果放第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>件物品，问题就转化为“前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>件物品放入剩下的容量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w-w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的背包中”，此时能获得的最大价值就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>w</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F[i-1,w-w_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>再加上通过放入第i件物品获得的价值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li></ul><h3 id="代码实现">代码实现</h3><p>先遍历物品再遍历容量(横向更新)<br><img src="/img/algorithm/01pack_2d.png" alt="二维实现"></p><p>先遍历容量再遍历物品(纵向更新)<br><img src="/img/algorithm/01pack_2d_packfirst.png" alt="二维实现"><br>蓝色方块表示更新完成，绿色表示当前需要更新的值，红色表示还未更新，带文字的方块表示更新当前值所需要的值。<br>可以看出，对于二维实现，先遍历背包容量或者先遍历物品都可以，因为更新当前位置所需信息时所需要的值(蓝色带文字方块)都已经更新完成</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>a</mi><mi>g</mi><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">bagWeight</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ba</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span>为背包重量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">weight</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span>表示重量数组，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span>表示价值数组，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先遍历物品再遍历容量(横向更新)      </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zeroOnePack</span><span class="params">(<span class="keyword">int</span> bagWeight,vector&lt;<span class="keyword">int</span>&gt; weight,vector&lt;<span class="keyword">int</span>&gt; value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = weight.<span class="built_in">size</span>(), n = bagWeight;</span><br><span class="line">    <span class="comment">// dp[i][j] 表示对于前i件物品，容量为j的背包所能获得的最大价值</span></span><br><span class="line">    <span class="comment">//初始化 dp[*][0] = 0 dp[0][*] = 0</span></span><br><span class="line">    <span class="keyword">int</span> dp[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m+<span class="number">1</span>; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n+<span class="number">1</span>; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i]) </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先遍历容量再遍历物品(纵向更新)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) </span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="空间优化">空间优化</h3><p>采用一维数组去替代二维数组，这要求在dp能够同时保存上一层信息和更新本层<br>因为更新当前位置所需信息只在<strong>上一层左边和正上方</strong>，必需采用逆序。<br><img src="/img/algorithm/01pack_1d.png" alt="一维实现"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zeroOnePack</span><span class="params">(<span class="keyword">int</span> bagWeight,vector&lt;<span class="keyword">int</span>&gt; weight,vector&lt;<span class="keyword">int</span>&gt; value)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="comment">//这样保证物体i只在本次循环被使用，因为等式右边的dp保存的是前i-1个物品</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[bagWeight];   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包">完全背包</h2><p>完全背包与0-1背包的区别在于物品的个数是无限的，即可重复选择相同物品填充</p><h3 id="基本思路-2">基本思路</h3><ol><li>基本思路<br>模仿0-1背包的解法</li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>w</mi><mo>−</mo><mi>k</mi><mo>∗</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo>+</mo><mi>k</mi><mo>∗</mo><msub><mi>v</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>k</mi><mo>∗</mo><msub><mi>w</mi><mi>i</mi></msub><mo>&lt;</mo><mo>=</mo><mi>W</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F[i,w] = max\{F[i-1,w-k*w_i]+k*v_i | 0&lt;=k*w_i&lt;=W\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mclose">}</span></span></span></span></span></p><ol start="2"><li>转换为0-1背包<br>每个物品i,最多能放<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>W</mi><msub><mi>w</mi><mi>i</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{W}{w_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3174em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0269em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>件，那么就把第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>件扩充至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>W</mi><msub><mi>w</mi><mi>i</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{W}{w_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3174em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0269em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>件，然后解决这个0-1背包问题<br>则状态转移方程便是<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>w</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo>+</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F[i,w] = max(F[i-1,w],F[i,w-w_i]+v_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p></li></ol><ul><li>如果不放第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>件物品，问题就转化为“前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>件物品放入容量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>的背包中”，价值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F[i-1,w]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span></span></span></span>；</li><li>在考虑“选一件第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>种物品”时，需要一个可能已选入第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>种物品的子结果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>w</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F[i,w-w_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>。而不是只选到前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的子结果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>w</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F[i-1,w-w_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li></ul><h3 id="二维实现">二维实现</h3><p>先遍历物品再遍历容量(横向更新)<br><img src="/img/algorithm/completepack_2d.png" alt="二维实现"><br>先遍历容量再遍历物品(纵向更新)<br><img src="/img/algorithm/completepack_2d_packfirst.png" alt="二维实现"></p><p>和0-1背包一样，对于二维实现，先遍历物品和先遍历容量都是可行的。原因就在于不管采用那种遍历顺利总是保证更新当前位置时所需要的信息已经准备好了</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>a</mi><mi>g</mi><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">bagWeight</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ba</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span>为背包重量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">weight</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span>表示重量数组，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span>表示价值数组，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">completePack</span><span class="params">(<span class="keyword">int</span> bagWeight,vector&lt;<span class="keyword">int</span>&gt; weight,vector&lt;<span class="keyword">int</span>&gt; value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = weight.<span class="built_in">size</span>(), n = bagWeight;</span><br><span class="line">    <span class="comment">// dp[i][j] 表示对于前i件物品，容量为j的背包所能获得的最大价值</span></span><br><span class="line">    <span class="comment">//初始化 dp[*][0] = 0 dp[0][*] = 0</span></span><br><span class="line">    <span class="keyword">int</span> dp[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m+<span class="number">1</span>; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n+<span class="number">1</span>; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i]) </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空间优化-2">空间优化</h3><p>采用一维数组去替代二维数组，<br>因为更新当前位置所需信息<strong>本层左边和正上方</strong>，对应到一维就是当前位置左边和自身位置，需采用正向遍历，及时更新本层左边方块<br><img src="/img/algorithm/completepack_1d.png" alt="一维实现"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">completePack</span><span class="params">(<span class="keyword">int</span> bagWeight,vector&lt;<span class="keyword">int</span>&gt; weight,vector&lt;<span class="keyword">int</span>&gt; value)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品       </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = weight[i]; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[bagWeight];   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>不管是0-1背包还是完全背包，其二维实现两种遍历顺序都是可以的</li><li>0-1背包和完全背包解决的是组合问题，并非排列问题，排列问题参考爬楼梯</li><li>0-1背包和完全背包组合问题都是外层遍历物品，内层遍历背包容量。</li><li>0-1背包是<strong>逆向</strong>遍历背包容量，保证当前物品最多一个被加入。完全背包<strong>正向</strong>遍历，使得可以当前物品可多次被加入</li><li>对于排列问题，先遍历背包，在遍历物品。<a href="https://leetcode-cn.com/problems/combination-sum-iv/">参考爬楼梯进阶版</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法(三)——堆、计数、桶、基数排序</title>
      <link href="/2021/12/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9503/"/>
      <url>/2021/12/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9503/</url>
      
        <content type="html"><![CDATA[<h3 id="堆排序">堆排序</h3><p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。</p><h4 id="堆的概念">堆的概念</h4><p>堆是一种完全二叉树，这使得堆(完全二叉树)可以用数组进行表示。如下图每一个节点对应数组的一个元素且可以通过数组下标来判断节点间位置。<br>对于给定下标为<code>i</code>的数组中的数组,其该元素所对应的父节点、孩子节点下标为(以1作为开始)：<br>父节点：    <code>Parent(i) = floor(i/2)</code><br>左孩子节点： <code>Left(i) = 2*i</code><br>右孩子节点:  <code>Right(i)= 2*i +1</code><br><img src="/img/algorithm/heap.png" alt="heap"></p><ul><li>最大堆即最大元素值出现在根结点，堆中每个父节点的元素值都大于等于其孩子结点 用于<strong>升序</strong>排列</li><li>最小堆中的最小元素值出现在根结点，堆中每个父节点的元素值都小于等于其孩子结点 用于<strong>降序</strong>排列</li></ul><h4 id="算法描述">算法描述</h4><p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作</p><ul><li><p>最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</p></li><li><p>创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆<br><img src="/img/algorithm/buildHeap.gif" alt="buildHeap"></p></li><li><p>移除位在第一个数据的根节点，并做最大堆调整的递归运算<br><img src="/img/algorithm/adjustHeap.gif" alt="adjustHeap"></p></li></ul><h4 id="算法实现">算法实现</h4><p>需要注意的一个问题是：数组都是 Zero-Based，这就意味着我们的堆数据结构模型要发生改变即<br>对于给定下标为<code>i</code>的数组中的数组,其该元素所对应的父节点、孩子节点下标为(以0作为开始)：<br>父节点：    <code>Parent(i) = floor((i-1)/2)</code><br>左孩子节点： <code>Left(i) = 2*i+1</code><br>右孩子节点:  <code>Right(i)= 2*(i+1)</code></p><p>对于利用堆排序，只关心两个问题</p><ol><li>给定一个无序数组，如何建立堆</li><li>删除堆顶元素，如何调整成为新的堆</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = len<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//初始化最大堆</span></span><br><span class="line">    <span class="comment">//从第一个非叶子节点开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">getParentIndex</span>(lastIndex); i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="built_in">adjustHeap</span>(arr,i,lastIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除堆顶元素,重新调整堆</span></span><br><span class="line">    <span class="keyword">while</span>(lastIndex&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>],arr[lastIndex]);</span><br><span class="line">        lastIndex--;</span><br><span class="line">        <span class="built_in">adjustHeap</span>(arr,<span class="number">0</span>,lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> curIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left,right,exchangeIndex;</span><br><span class="line">    left = <span class="built_in">getLeftChildIndex</span>(curIndex);</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= endIndex)&#123;</span><br><span class="line">        <span class="comment">//选择左右孩子中较大的进行交换</span></span><br><span class="line">        right = left  + <span class="number">1</span>;</span><br><span class="line">        exchangeIndex = left;</span><br><span class="line">        <span class="keyword">if</span>(right &lt;= endIndex &amp;&amp; arr[left] &lt; arr[right])&#123;</span><br><span class="line">            exchangeIndex = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若当前节点小于其孩子节点，交换并下沉</span></span><br><span class="line">        <span class="keyword">if</span>(arr[curIndex] &lt; arr[exchangeIndex])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[curIndex],arr[exchangeIndex]);</span><br><span class="line">            curIndex = exchangeIndex;</span><br><span class="line">            left = <span class="built_in">getLeftChildIndex</span>(curIndex);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParentIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (index<span class="number">-1</span>) /<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLeftChildIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法特点">算法特点</h4><ol><li>堆排序存在大量的筛选和移动过程，属于不稳定的排序算法</li><li>堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用</li><li>在元素比较多的情况下,尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。</li></ol><h3 id="计数排序">计数排序</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是<strong>有确定范围的整数</strong>。</p><h4 id="算法描述-2">算法描述</h4><ol><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li></ol><h4 id="动图演示">动图演示</h4><p><img src="/img/algorithm/countSort.gif" alt="countSort"></p><h4 id="算法实现-2">算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len, <span class="keyword">int</span> maxVal, <span class="keyword">int</span> minVal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cntLen = maxVal- minVal + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>* cntVec = <span class="keyword">new</span> <span class="keyword">int</span>[cntLen];</span><br><span class="line">    <span class="comment">//初始化为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = minVal; i &lt;= maxVal;i++)</span><br><span class="line">        cntVec[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计每个值出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++ )&#123;</span><br><span class="line">        cntVec[arr[i]-minVal]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照计数顺序将其依次填充到原数组中</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;  <span class="comment">//指向计数数组</span></span><br><span class="line">    <span class="keyword">int</span> curIndex = <span class="number">0</span>; <span class="comment">//指向需要被填充的数组</span></span><br><span class="line">    <span class="keyword">while</span>(p &lt; cntLen)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cntVec[p] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            arr[curIndex++] = p + minVal;</span><br><span class="line">            cntVec[p]--;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []cntVec;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法特点-2">算法特点</h4><ol><li>排序目标要能够映射到整数域，其最大值最小值应当容易辨别</li><li>计数排序需要占用大量空间，它比较适用于数据比较集中的情况</li></ol><h3 id="桶排序">桶排序</h3><p>桶排序又叫箱排序，是计数排序的升级版，它的工作原理是将数组分到有限数量的桶子里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。</p><blockquote><p>计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况<br>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p></blockquote><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><h4 id="算法描述-3">算法描述</h4><ol><li>找出待排序数组中的最大值max、最小值min</li><li>使用数组作为桶，桶里放的元素用存储。桶的数量为(max-min)/arr.length+1</li><li>遍历数组 arr，计算每个元素 arr[i] 放的桶</li><li>每个桶各自排序</li><li>遍历桶数组，把排序好的元素放进输出数组</li></ol><h4 id="图片解释">图片解释</h4><p><img src="/img/algorithm/bucketSort.png" alt="bucketSort"></p><h4 id="算法特点-3">算法特点</h4><ol><li>当输入数据可以均匀的分配到桶最快</li><li>空间复杂度：O(n+k)，时间复杂度O(n+k)</li></ol><h3 id="基数排序">基数排序</h3><p>基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。<br>排序过程：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p><p>实际上，基数排序算法对排序元素的类型不要求一定是非负整数才可以进行，其对于字符串、浮点数等类型均可适用。其关键在于要求排序元素的数位长度统一。例如对整数排序时，如果排序元素中含有负数，则可以对排序元素均加上一个数使其全部为非负整数；如果元素类型是字符串的话，在计数排序过程中，可以直接使用该位字符对应ASCII码值进行计数，对于长度不足的字符串，可直接在其后面补0实现长度对齐。即在计数排序过程中，如果发现某位字符是为对齐所填充的0的话，则可认为其对应的ASCII码值为0进行计数，因为字符’A’所对应的ASCII码值是65，字符’0’所对应的ASCII码值是48，均比0大。这样即可保证基数排序的结果是符合字典序的实现</p><h4 id="动图演示-2">动图演示</h4><p><img src="/img/algorithm/radixSort.gif" alt="radixSort"></p><h4 id="算法特点-4">算法特点</h4><ol><li><p>通过上面的排序过程，我们可以看到，每一轮映射和收集操作，都保持从左到右的顺序进行，如果出现相同的元素，则保持他们在原始数组中的顺序。可见，基数排序是一种稳定的排序。</p></li><li><p>基数排序要求较高，元素必须是整数，整数时长度10W以上，最大值100W以下效率较好，但是基数排序比其他排序好在可以适用字符串，或者其他需要根据多个条件进行排序的场景，例如日期，先排序日，再排序月，最后排序年 ，其它排序算法可是做不了的</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法(二)——希尔、快速、归并</title>
      <link href="/2021/12/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9502/"/>
      <url>/2021/12/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9502/</url>
      
        <content type="html"><![CDATA[<h3 id="希尔排序-插入排序的改良版">希尔排序(插入排序的改良版)</h3><p>在希尔排序出现之前，计算机界普遍存在“排序算法不可能突破O(n2)”的观点。希尔排序是第一个突破O(n2)的排序算法，它是简单插入排序的改进版。希尔排序的提出，主要基于以下两点：</p><ol><li>插入排序算法在数组基本有序的情况下，可以近似达到O(n)复杂度，效率极高。</li><li>但插入排序每次只能将数据移动一位，在数组较大且基本无序的情况下性能会迅速恶化。</li></ol><h4 id="算法描述">算法描述</h4><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录&quot;基本有序&quot;时，再对全体记录进行依次直接插入排序</p><ol><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行 k 趟排序</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度<br><img src="/img/algorithm/shellSortDes.png" alt="希尔排序"></li></ol><h4 id="动图演示">动图演示</h4><p><img src="/img/algorithm/shellSort.gif" alt="希尔排序"></p><h4 id="算法实现">算法实现</h4><p>在希尔排序的理解时，我们倾向于对于每一个分组，逐组进行处理，但在代码实现中，我们可以不用这么按部就班地处理完一组再调转回来处理下一组,实现时不用循环按组处理，我们可以从第gap个元素开始，逐个跨组处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Donald Shell增量 每次分组减半</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">//增量delta，并逐步缩小增量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> delta = len / <span class="number">2</span>; delta &gt;<span class="number">0</span>; delta /= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//从第delta个元素开始，逐个对其所在组进行直接插入排序操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = delta; i&lt;len;i++)&#123;</span><br><span class="line">            <span class="comment">//寻找可以插入的位置</span></span><br><span class="line">            <span class="keyword">int</span> pos = i;</span><br><span class="line">            <span class="keyword">int</span> curVal = arr[i];</span><br><span class="line">            <span class="keyword">while</span>(pos &gt;= delta &amp;&amp; arr[pos-delta] &gt; curVal)&#123;</span><br><span class="line">                arr[pos] = arr[pos-delta];</span><br><span class="line">                pos-=delta;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[pos] = curVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法特点">算法特点</h4><ol><li>希尔排序的增量数列可以任取，需要的唯一条件是最后一个一定为1（因为要保证按1有序）</li><li>Donald Shell提出的增量，即折半降低直到1,其时间复杂度还是O(n2)。Hibbard经过复杂证明可使得最坏时间复杂度为O(n3/2)</li><li>Shell排序不是一个稳定的算法</li></ol><h3 id="快速排序">快速排序</h3><p>快速排序算法知名度较高，对于大数据具有优秀的排序性能和相对简单的算法实现。快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><h4 id="算法描述-2">算法描述</h4><ol><li>从序列中挑出一个元素作为基准(pivot)</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区(partition)操作。</li><li>递归的把左右两边的字序列进行排序</li><li>直到子数组长度为1</li></ol><h4 id="动图演示-2">动图演示</h4><p><img src="/img/algorithm/quickSort.gif" alt="快速排序"></p><h4 id="算法实现-2">算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//left 数组起始下标</span></span><br><span class="line">    <span class="comment">//right 数组结束下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归终止条件 数组长度为1</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//执行partition操作，将数组分为两个子数组</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = <span class="built_in">partition</span>(arr,left,right);</span><br><span class="line">    <span class="comment">//递归调用</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr,left,pivotIndex<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr,pivotIndex,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//选定第一个元素作为基准(可随意)</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="comment">//所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;right)&#123;</span><br><span class="line">        <span class="comment">//采取双指针的方式,移动left和right</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;right &amp;&amp; arr[right] &gt;=pivot)</span><br><span class="line">            --right;</span><br><span class="line">        arr[left] = arr[right]; <span class="comment">//交换比基准值小的至左边</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;right &amp;&amp; arr[left] &lt;=pivot)</span><br><span class="line">            ++left;</span><br><span class="line">        arr[right] = arr[left]; <span class="comment">//交换比基准值大的至右边</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//扫描完成，基准到位</span></span><br><span class="line">        arr[left] = pivot;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//划分第二方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//随机选中一个元素作为基准arr[p],并放置末尾</span></span><br><span class="line">    <span class="comment">//swap(arr[p],arr[right]);</span></span><br><span class="line">    <span class="comment">//这里直接选择arr[right]作为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[right];</span><br><span class="line">    <span class="comment">//双指针</span></span><br><span class="line">    <span class="comment">//[left,i）均小于等于pivot</span></span><br><span class="line">    <span class="comment">//[i,j)均大于等于pivot</span></span><br><span class="line">    <span class="comment">//[j,right）表示未扫描区间</span></span><br><span class="line">    <span class="keyword">int</span> i = left; </span><br><span class="line">    <span class="comment">//扫描除基准外的元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = left;j &lt; right;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &lt;= pivot)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将基准放置正确位置</span></span><br><span class="line">    <span class="built_in">swap</span>(arr[i],arr[right]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/algorithm/partition.png" alt="partition"></p><h4 id="算法特点-2">算法特点</h4><ol><li>快速排序并不是稳定的。这是因为我们无法保证相等的数据按顺序被扫描到和按顺序存放</li><li>在最坏状况下时间复杂度(顺序数列)则需要 Ο(n2),平均Ο(nlogn)</li></ol><h3 id="归并排序">归并排序</h3><h4 id="算法描述-3">算法描述</h4><p><img src="/img/algorithm/mergeSort.png" alt="mergeSort"></p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一指针到达序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol><h4 id="动图演示-3">动图演示</h4><p><img src="/img/algorithm/mergeSort.gif" alt="mergeSort"></p><h4 id="算法实现-3">算法实现</h4><h5 id="数组排序">数组排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left) /<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//左数组 [left,mid] 右子数组[mid+1,right]</span></span><br><span class="line">    <span class="built_in">mergeSort</span>(arr,left,mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr,mid+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="built_in">merge</span>(arr,left,mid,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并两个有序数组</span></span><br><span class="line"><span class="comment">//左数组 [left,mid] 右子数组[mid+1,right]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//申请空间</span></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//合并两个子数组</span></span><br><span class="line">    <span class="keyword">int</span> i = left,j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">        p[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;=mid)&#123;</span><br><span class="line">        p[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( j&lt;=right)&#123;</span><br><span class="line">        p[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把数据复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = left;i&lt;=right;i++)&#123;</span><br><span class="line">        arr[i] = p[i-left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="链表归并排序">链表归并排序</h5><p><img src="/img/algorithm/ListMergeSort.png" alt="ListMergeSort"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的归并排序</span></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mergeSort</span>(head,<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从头到尾进行排序，返回排序好的头指针</span></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeSort</span><span class="params">(ListNode* head,ListNode* tail)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只剩最后一个节点,tail不进行排序</span></span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next == tail)&#123;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快慢指针寻找中间</span></span><br><span class="line">    ListNode* slow = head,*fast =head,*mid = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != tail)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast != tail)</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    mid = slow;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">mergeSort</span>(head,mid),<span class="built_in">mergeSort</span>(mid,tail));</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* list1,ListNode* list2)</span></span>&#123;</span><br><span class="line">    ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* pre = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(list1 &amp;&amp; list2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1-&gt;val &lt; list2-&gt;val)&#123;</span><br><span class="line">            pre-&gt;next = list1;</span><br><span class="line">            list1 = list1-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre-&gt;next = list2;</span><br><span class="line">            list2 = list2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(list1)&#123;</span><br><span class="line">        pre-&gt;next = list1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pre-&gt;next = list2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法特点-3">算法特点</h4><ol><li>时间复杂度平均Ο(nlogn),对于数组需要O(n)的空间复杂度，对于链表只需要O(1)</li><li>常用于给链表排序</li><li>因为我们在遇到相等的数据的时候必然是按顺序“抄写”到辅助数组上的，所以，归并排序同样是稳定算法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法(一)——冒泡、选择、插入</title>
      <link href="/2021/12/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9501/"/>
      <url>/2021/12/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9501/</url>
      
        <content type="html"><![CDATA[<p>排序算法是最基本的算法。排序算法分为<strong>内部排序</strong>和<strong>外部排序</strong>。</p><p>内部排序：数据记录在内存中进行排序，不需要访问外存</p><p>外部排序：因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p><p>常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：</p><p><img src="/img/algorithm/sort.png" alt="排序"></p><p>名词解释:</p><ul><li>n 数据规模</li><li>k 桶的个数</li><li>In-place 占用常数内存，不占用额外内存</li><li>Out-place 占用额外内存</li><li>稳定性 排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li></ul><h3 id="冒泡排序">冒泡排序</h3><p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢&quot;浮&quot;到数列的顶端。</p><h4 id="算法描述">算法描述</h4><ol><li>比较相邻元素，如果第一个比第二个大，则交换他们的位置</li><li>对每一对相邻元素对同样的工作，从开始第一对到结尾的最后一对，</li><li>针对所有元素重复以上的步骤，除了最后一个</li><li>重复步骤1～3,知道所有排序完成</li></ol><h4 id="动图演示">动图演示</h4><p><img src="/img/algorithm/bubbleSort.gif" alt="冒泡排序"></p><h4 id="算法实现">算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;<span class="comment">// 需要排序的长度，共len-1次循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;<span class="comment">//从第1个元素到第i个元素</span></span><br><span class="line">          <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])</span><br><span class="line">              <span class="built_in">swap</span>(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="comment">//end loop j</span></span><br><span class="line">    &#125;<span class="comment">//end loop i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法特点">算法特点</h4><ol><li>在相邻元素相等时，它们并不会交换位置，所以，冒泡排序是稳定排序</li><li>每完成一次第一层循环，会使得当前需要排序的数组<code> arr[0]-arr[i]</code>中最大的数被放置末尾下标为<code>i</code>的位置</li><li>算法复杂度总是O(n^2)，除非有序状态下提前结束，也需要O(n)</li><li>冒泡排序思路简单，代码也简单，特别适合小数据的排序。但是，由于算法复杂度较高，在数据量大的时候不适合使用。</li></ol><h4 id="代码优化">代码优化</h4><p>要使算法在最佳情况下有O(n)复杂度，需要做一些改进，增加一个<code>swap</code>的标志，当前一轮没有进行交换时，说明数组已经有序，没有必要再进行下一轮的循环了，直接退出。(意义不大)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isSwap = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;<span class="comment">// 需要排序的长度，共len-1次循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;<span class="comment">//从第1个元素到第i个元素</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">              <span class="built_in">swap</span>(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">              isSwap = <span class="literal">true</span>;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;<span class="comment">//end loop j</span></span><br><span class="line">      <span class="comment">//没有交换，提前结束</span></span><br><span class="line">      <span class="keyword">if</span>(!isSwap)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="comment">//end loop i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序">选择排序</h3><p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。</p><h4 id="算法描述-2">算法描述</h4><ol><li>在<strong>未排序</strong>序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>从剩余未排序元素中继续寻找最小（大）元素，然后放到<strong>已排序</strong>序列的末尾</li><li>重复第二步，直到所有元素均排序完毕</li></ol><h4 id="动图演示-2">动图演示</h4><p><img src="/img/algorithm/selectionSort.gif" alt="选择排序"></p><h4 id="算法实现-2">算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minIndex;</span><br><span class="line">    <span class="comment">//有序序列 [0,i)</span></span><br><span class="line">    <span class="comment">//无序序列 [i,len)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="comment">//寻找无序序列中中最小的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =i;j&lt;len;j++)</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min])&#123;</span><br><span class="line">              minIndex = j;</span><br><span class="line">            &#125;      </span><br><span class="line">      <span class="comment">//将最小值与无序序列第一个值交换</span></span><br><span class="line">      <span class="built_in">swap</span>(arr[minIndex],arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法特点-2">算法特点</h4><ol><li>选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是优于冒泡排序的</li><li>数组实现的选择排序是不稳定的，用链表实现的选择排序是稳定的</li><li>算法复杂度总是O(n^2)</li></ol><h3 id="插入排序">插入排序</h3><p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p><h4 id="算法描述-3">算法描述</h4><ol><li>把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的</li><li>从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置</li><li>重复上述过程直到最后一个元素被插入有序子数组中</li></ol><h4 id="动图演示-3">动图演示</h4><p><img src="/img/algorithm/insertionSort.gif" alt="插入排序"></p><h4 id="算法实现-3">算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">//有序序列 [0,i）</span></span><br><span class="line">    <span class="comment">//无序序列 [i,len)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">//需要插入的值</span></span><br><span class="line">        <span class="keyword">int</span> curVal = arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找可以插入的位置</span></span><br><span class="line">        <span class="keyword">int</span> pos = i;</span><br><span class="line">        <span class="comment">//逐个比较，若arr[pos-1]大于插入的值则向后移动</span></span><br><span class="line">        <span class="keyword">while</span>(pos &gt;=<span class="number">1</span> &amp;&amp; arr[pos<span class="number">-1</span>]&gt;curVal)&#123;</span><br><span class="line">            arr[pos] = arr[pos<span class="number">-1</span>];</span><br><span class="line">            pos--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[pos] = curVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法特点-3">算法特点</h4><ol><li>由于只需要找到不大于当前数的位置而并不需要交换，因此，直接插入排序是稳定的排序方法</li><li>算法复杂度总是O(n^2),在数据比较少的时候，是一个不错的选择，一般做为快速排序的扩充</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker容器cron任务读取环境变量</title>
      <link href="/2021/11/28/docker%E5%AE%B9%E5%99%A8cron%E4%BB%BB%E5%8A%A1%E8%AF%BB%E5%8F%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2021/11/28/docker%E5%AE%B9%E5%99%A8cron%E4%BB%BB%E5%8A%A1%E8%AF%BB%E5%8F%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>​因为<em>cron</em>从非交互式、非登录 shell 运行作业。所以当<a href="https://www.baeldung.com/cron-expressions"><em>cron</em></a>执行作业时，它不会从<a href="https://www.baeldung.com/linux/bashrc-vs-bash-profile-vs-profile"><em>~/.bashrc</em></a><a href="https://www.baeldung.com/linux/bashrc-vs-bash-profile-vs-profile">、</a><a href="https://www.baeldung.com/linux/bashrc-vs-bash-profile-vs-profile"><em>~/.bash_profile</em></a><a href="https://www.baeldung.com/linux/bashrc-vs-bash-profile-vs-profile">、</a><a href="https://www.baeldung.com/linux/bashrc-vs-bash-profile-vs-profile"><em>/etc/profile 等</em></a>文件加载<a href="https://www.baeldung.com/linux/environment-variables">环境变量</a>。当我们需要使用容器内的环境变量作为参数定时运行shell脚本时，由于无法读取环境变量导致运行失败。</p><p>以下为docker容器的解决方案</p><h2 id="解决方案">解决方案</h2><ol><li><p>保存容器环境变量(可以写在entrypoint中)</p><p>通过declare命令和grep命令捕获你所需要的环境变量至/container.env文件中(当然，这个文件你可以随意定义)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare -p | gerp -E &#x27;VAR1|VAR2|VAR2&#x27; &gt; /container.env</span><br></pre></td></tr></table></figure></li><li><p>运行时载入环境变量配置文件</p><p>有两种方式载入。</p><ol><li><p>通过需要执行的shell脚本载入，只需在shell脚本前加入即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取容器设定的环境变量</span></span><br><span class="line">source /container.env</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>直接在crontab中载入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL=/bin/bash</span><br><span class="line">BASH_ENV=/container.env</span><br><span class="line">* * * * * root /test-cron.sh</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="cron注意事项">cron注意事项</h2><p>不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量</p><ol><li>脚本中涉及文件路径时写全局路径(如python 通过which python 定位其全局路径再填入)</li><li>脚本执行其他环境变量时，通过source命令引入环境变量</li><li>当手动执行脚本OK，但是crontab执行失败时。很有可能环境变量出问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> cron </tag>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(十五)-“数据结构”模式</title>
      <link href="/2021/11/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16/"/>
      <url>/2021/11/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16/</url>
      
        <content type="html"><![CDATA[<h1>“数据结构”模式</h1><p>常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。主要有以下三种</p><ol><li>Composite</li><li>Iterator</li><li>Chain of Resposibility</li></ol><h1>Composite</h1><h2 id="设计动机">设计动机</h2><ol><li>在软件在某些情况下，客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构(而非抽象接口)的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。</li><li>如何将“客户代码与复杂的对象容器结构&quot;解耦?让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器?</li></ol><h2 id="定义">定义</h2><blockquote><p>将对象组合成<strong>树形结构</strong>以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性(稳定)</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/16_01.png" alt="结构"></p><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Component</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span>:</span><span class="keyword">public</span> Component&#123;</span><br><span class="line">    string name;</span><br><span class="line">    list&lt;Component*&gt; elements; <span class="comment">//通常保存叶子结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Composite</span>(<span class="keyword">const</span> string&amp; s):<span class="built_in">name</span>(s)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component* element)</span></span>&#123;</span><br><span class="line">        elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component* element)</span></span>&#123;</span><br><span class="line">        elements.<span class="built_in">remove</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. 处理当前结点</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.处理叶子结点</span></span><br><span class="line">        <span class="comment">//多态调用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : elements)&#123;</span><br><span class="line">            e-&gt;<span class="built_in">process</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叶子结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span>:</span><span class="keyword">public</span> Component&#123;</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Leaf</span>(<span class="keyword">const</span> string&amp; s):<span class="built_in">name</span>(s)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="comment">//处理当前结点</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Invoke</span><span class="params">(Component&amp; c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将一对多转化为一对一的关系</span></span><br><span class="line">    c.<span class="built_in">process</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Composite <span class="title">root</span><span class="params">(<span class="string">&quot;root&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode1</span><span class="params">(<span class="string">&quot;treeNode1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode2</span><span class="params">(<span class="string">&quot;treeNode2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode3</span><span class="params">(<span class="string">&quot;treeNode3&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">leaf1</span><span class="params">(<span class="string">&quot;leaf1&quot;</span>)</span></span></span><br><span class="line"><span class="function">    Leaf <span class="title">leaf2</span><span class="params">(<span class="string">&quot;leaf2&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    root.<span class="title">add</span><span class="params">(&amp;treeNode1)</span></span>;</span><br><span class="line">    treeNode1.<span class="built_in">add</span>(&amp;treeNode2);</span><br><span class="line">    treeNode1.<span class="built_in">add</span>(&amp;treeNode3);</span><br><span class="line">    treeNode2.<span class="built_in">add</span>(&amp;leaf1);</span><br><span class="line">    treeNode3.<span class="built_in">add</span>(&amp;leaf2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Invoke处理一致性</span></span><br><span class="line">    <span class="built_in">Invoke</span>(root);</span><br><span class="line">    <span class="built_in">Invoke</span>(treeNode1);</span><br><span class="line">    <span class="built_in">Invoke</span>(leaf1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>Composite模式采用树形结构来实现普遍存在的对象容器，从而将‘一对多”的关系转化为“一对一”的关系，使得客户代码可以一致地(复用)处理对象和对象容器，无需关心处理的是单个的对象，还是组合的对象容器。</li><li>将“客户代码与复杂的对象容器结构”解耦是Composite的核心思想，解耦之后，客户代码将与纯粹的抽象接口一而非对象容器的内部实现结构一发生依赖，从而更能“应对变化”。</li><li>Composite模式在具体实现中，可以让父对象中的子对象反向追溯;如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。</li></ol><h1>Iterator</h1><h2 id="设计动机-2">设计动机</h2><ol><li>在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素;同时这种“透明遍历”也为“同一种算法在多种集合对象上进行操作’’提供了可能。</li><li>使用面向对象技术将这种遍历机制抽象为“迭代器对象”为“应对变化中的集合对象”提供了一种优雅的方式。</li></ol><h2 id="定义-2">定义</h2><blockquote><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露(稳定)该对象的内部表示。</p></blockquote><h2 id="结构-2">结构</h2><p><img src="/img/PatternDesign/16_02.png" alt="结构"></p><h2 id="总结-2">总结</h2><ol><li>在如今拥有STL和泛型编程的c++语言这种模式已被弃用(面对对象的迭代器性能损耗高),java,c#会用到</li><li>迭代抽象:访问一个聚合对象的内容而无需暴露它的内部表示。</li><li>迭代多态:为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构.上进行操作。</li><li>迭代器的健壮性考虑:遍历的同时更改迭代器所在的集合结构，会导致问题。</li></ol><h1>Chain of responsibility</h1><h2 id="设计动机-3">设计动机</h2><ol><li>在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接受者，如果显式指定，将必不可少地带来请求发送者与接受者的紧耦合。<br>2.如何使请求的发送者不需要指定具体的接受者?让请求的接受者自己在运行时决定来处理请求，从而使两者解耦。</li></ol><h2 id="定义-3">定义</h2><blockquote><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。</p></blockquote><h2 id="结构-3">结构</h2><p><img src="/img/PatternDesign/16_03.png" alt="结构"></p><h2 id="例子-2">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">RequestType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    REQ_HANDLER1,</span><br><span class="line">    REQ_HANDLER2,</span><br><span class="line">    REQ_HANDLER3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reqest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string description;</span><br><span class="line">    RequestType reqType;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Reqest</span>(<span class="keyword">const</span> string &amp; desc, RequestType type) : <span class="built_in">description</span>(desc), <span class="built_in">reqType</span>(type) &#123;&#125;</span><br><span class="line">    <span class="function">RequestType <span class="title">getReqType</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reqType; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> string&amp; <span class="title">getDescription</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> description; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChainHandler</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    ChainHandler *nextChain;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendReqestToNextHandler</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextChain != <span class="literal">nullptr</span>)</span><br><span class="line">            nextChain-&gt;<span class="built_in">handle</span>(req);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ChainHandler</span>() &#123; nextChain = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNextChain</span><span class="params">(ChainHandler *next)</span> </span>&#123; nextChain = next; &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">canHandleRequest</span>(req))</span><br><span class="line">            <span class="built_in">processRequest</span>(req);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">sendReqestToNextHandler</span>(req);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler1</span> :</span> <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.<span class="built_in">getReqType</span>() == RequestType::REQ_HANDLER1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler1 is handle reqest: &quot;</span> &lt;&lt; req.<span class="built_in">getDescription</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler2</span> :</span> <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.<span class="built_in">getReqType</span>() == RequestType::REQ_HANDLER2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler2 is handle reqest: &quot;</span> &lt;&lt; req.<span class="built_in">getDescription</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler3</span> :</span> <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.<span class="built_in">getReqType</span>() == RequestType::REQ_HANDLER3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler3 is handle reqest: &quot;</span> &lt;&lt; req.<span class="built_in">getDescription</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Handler1 h1;</span><br><span class="line">    Handler2 h2;</span><br><span class="line">    Handler3 h3;</span><br><span class="line">    h1.<span class="built_in">setNextChain</span>(&amp;h2);</span><br><span class="line">    h2.<span class="built_in">setNextChain</span>(&amp;h3);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Reqest <span class="title">req</span><span class="params">(<span class="string">&quot;process task ... &quot;</span>, RequestType::REQ_HANDLER3)</span></span>;</span><br><span class="line">    h1.<span class="built_in">handle</span>(req);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-3">总结</h2><ol><li>Chain of Responsibility模式的应用场合在于“一个请求可能有多个接受者，但是最后真正的接受者只有一个”，这时候请求发送者与接受者的耦合有可能出现“变化脆弱”的症状，职责链的目的就是将二者解耦，从而更好地应对变化。</li><li>应用了Chain of Responsibility模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加/修改请求的处理职责。</li><li>如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的责任，而不是发出请求的对象的责任。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(十四)-Memento</title>
      <link href="/2021/11/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F15/"/>
      <url>/2021/11/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F15/</url>
      
        <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。</li><li>如何实现对象状态的良好保存与恢复?但同时又不会因此而破坏对象本身的封装性。</li></ol><h2 id="定义">定义</h2><blockquote><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/15_01.png" alt="结构"></p><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  状态快照</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memento</span>&#123;</span></span><br><span class="line">    string state;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Memento</span>(<span class="keyword">const</span> string&amp; s):<span class="built_in">state</span>(s)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">getState</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">        state = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Originator</span>&#123;</span></span><br><span class="line">    string state;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Originator</span>()&#123;&#125;</span><br><span class="line">    Memento createMemento&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Memento</span>(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        state = memento.<span class="built_in">getState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Originator originator;</span><br><span class="line">    <span class="comment">//捕获对象状态，存储快照</span></span><br><span class="line">    Memento m = originator.<span class="built_in">createMemento</span>();</span><br><span class="line">    <span class="comment">//恢复快照</span></span><br><span class="line">    originator.<span class="built_in">setMemento</span>(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>备忘录(Memento)存储原发器(Originator)对象的内部状态，在需要时恢复原发器状态。</li><li>Memento模式的核心是信息隐藏，即Originator需要向外接隐藏信息，保持其封装性。但同时又需要将状态保持到外界(Memento) 。</li><li>由于现代语言运行时（如C#、Java等）都具有相当的对象序列化支持，因此往往采用效率较高、又较容易正确实现的序列化方案来买现Memento模式。</li></ol><h2 id="状态变化-模式">&quot;状态变化&quot;模式</h2><blockquote><p>在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理?同时又维持高层模块的稳定?“状态变化&quot;模式为这一问题提供了一种解决方案。</p></blockquote><h3 id="典型模式">典型模式</h3><ol><li><a href="/2021/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/">State</a></li><li><a href="/2021/11/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F15/">Memento</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(十三)-State</title>
      <link href="/2021/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/"/>
      <url>/2021/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/</url>
      
        <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在软件构建过程中，某些对象的状态如果改变，其行为也会随之，而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。</li><li>如何在运行时根据对象的状态来透明地更改对象的行为?而不会为对象操作和状态转化之间引入紧耦合?</li></ol><h2 id="定义">定义</h2><blockquote><p>允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为。</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/14_01.png" alt="结构"></p><h2 id="例子">例子</h2><h3 id="传统">传统</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NetworkState</span>&#123;</span></span><br><span class="line">    NetworkOpen,</span><br><span class="line">    NetworkClose,</span><br><span class="line">    NetworkConnect,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkProcess</span>&#123;</span></span><br><span class="line">    NetworkState state;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state == NetworkOpen)&#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//state change</span></span><br><span class="line">            state  = NetworkClose;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == NetworkClose)&#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//state change</span></span><br><span class="line">            state  = NetworkConnect;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == NetworkConnect)&#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//state change</span></span><br><span class="line">            state  = NetworkOpen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state == NetworkOpen)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == NetworkClose)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            state  = NetworkConnect;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == NetworkConnect)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            state  = NetworkOpen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态模式">状态模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenState</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloseState</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectState</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkState</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NetworkState* pNext; <span class="comment">//next state</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供接口，等待子类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">NetworkState</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开启状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenState</span>:</span><span class="keyword">public</span> NetworkState&#123;</span><br><span class="line">    <span class="comment">//单例，只有一个状态实例</span></span><br><span class="line">    <span class="keyword">static</span> NetworkState* m_instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> NetworkState* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">OpenState</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="comment">//state change</span></span><br><span class="line">        pNext  = CloseState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloseState</span>:</span><span class="keyword">public</span> NetworkState&#123;</span><br><span class="line">    <span class="comment">//单例，只有一个状态实例</span></span><br><span class="line">    <span class="keyword">static</span> NetworkState* m_instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> NetworkState* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">CloseState</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="comment">//state change</span></span><br><span class="line">        pNext  = ConnectState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectState</span>:</span><span class="keyword">public</span> NetworkState&#123;</span><br><span class="line">    <span class="comment">//单例，只有一个状态实例</span></span><br><span class="line">    <span class="keyword">static</span> NetworkState* m_instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> NetworkState* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">ConnectState</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="comment">//state change</span></span><br><span class="line">        pNext  = OpenState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NetworkState* OpenState::m_instance = <span class="literal">nullptr</span>;</span><br><span class="line">NetworkState* CloseState::m_instance = <span class="literal">nullptr</span>;</span><br><span class="line">NetworkState* ConnectState::m_instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkProcessor</span>&#123;</span></span><br><span class="line">    NetworkState* pState;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">NetworkProcessor</span>(NetworkState* state):<span class="built_in">pState</span>(state)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        pState-&gt;<span class="built_in">operator1</span>();</span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态切换时，切换相应的对象;但同时维持State的接口，这样实现了具体操作与状态转换之间的解耦。</li><li>为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的——即要么彻底转换过来，要么不转换。</li><li>如果State对象没有实例变量，那么各个上下文可以共享同一个State对象，从而节省对象开销。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(十二)-Mediator</title>
      <link href="/2021/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13/"/>
      <url>/2021/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13/</url>
      
        <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。</li><li>在这种情况下，我们可使用一个“中介对象&quot;来管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系，从而更好地抵御变化。</li></ol><h2 id="定义">定义</h2><blockquote><p>用一个中介对象来封装(封装变化)一系列的对象交互。中介者使各对象不需要显式的相互引用(编译时依赖→运行时依赖)，从而使其耦合松散(管理变化)，而且可以独立地改变它们之间的交互。</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/13_01.png" alt="结构"></p><h2 id="总结">总结</h2><ol><li>将多个对象间复杂的关联关系解耦，Mediator模式将多个对象间的控制逻辑进行集中管理，变“多个对象互相关联&quot;为“多个对象和一个中介者关联”，简化了系统的维护，抵御了可能的变化。</li><li>随着控制逻辑的复杂化，Mediator具体对象的实现可能相当复杂。这时候可以对Mediator对象进行分解处理。</li><li>Façade模式是解耦系统间(单向)的对象关联关系;ediator模式是解耦系统内各个对象之间(双向)的关联关系。</li></ol><h2 id="接口隔离-模式">&quot;接口隔离&quot;模式</h2><blockquote><p>在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。</p></blockquote><h3 id="典型模式">典型模式</h3><ol><li><a href="/2021/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10/">Façade</a>    -解决系统内外的接口问题</li><li><a href="/2021/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/">Proxy</a>     -解决两对象之间的接口问题</li><li><a href="/2021/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/">Adapter</a>   -解决新老接口之间转换问题</li><li><a href="/2021/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13/">Mediator</a>  -解决多个对象复杂关联问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(十一)-Adapter</title>
      <link href="/2021/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/"/>
      <url>/2021/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/</url>
      
        <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。</li><li>如何应对这种“迁移的变化&quot;?如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口?</li></ol><h2 id="定义">定义</h2><blockquote><p>将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/12_01.png" alt="结构"></p><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遗留接口(老接口)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IAdaptee</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遗留类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Oldclass</span> :</span> <span class="keyword">public</span> IAdaptee&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标接口(新接口)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ITarget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">porcess</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象适配器(继承＋组合)</span></span><br><span class="line"><span class="comment">//继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> :</span><span class="keyword">public</span> ITarget&#123; </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//组合</span></span><br><span class="line">    IAdaptee* pAdaptee;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Adapter</span>(IAdaptee* adaptee):<span class="built_in">pAdaptee</span>(adaptee)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">porcess</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用旧接口</span></span><br><span class="line">        <span class="built_in">foo</span>();</span><br><span class="line">        <span class="built_in">bar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类适配器 多继承(不推荐使用)</span></span><br><span class="line"><span class="comment">//缺乏灵活性，不是针对接口，定死在了Oldclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter1</span> :</span><span class="keyword">public</span> ITarget,<span class="keyword">protected</span> Oldclass&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IAdaptee* pAdaptee = <span class="keyword">new</span> <span class="built_in">Oldclass</span>();</span><br><span class="line">    ITarget* pTarget = <span class="keyword">new</span> <span class="built_in">Adapter</span>(pAdaptee);</span><br><span class="line">    pTarget-&gt;<span class="built_in">process</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li><p>Adapter模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。</p></li><li><p>-GoF 23定义了两种Adapter模式的实现结构:对象适配器和类适配器。但类适配器采用“多继承&quot;的实现方式，一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神。</p></li><li><p>Adapter模式可以实现的非常灵活，不必拘泥于Gof23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象&quot;作为新的接口方法参数，来达到适配的目的。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(十)-Proxy</title>
      <link href="/2021/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/"/>
      <url>/2021/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/</url>
      
        <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在面向对象系统中，有些对象由于某种原因(比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等)直接访问会给使用者、或者系统结构带来很多麻烦。</li><li>如何在不失去透明操作对象的同时来管理/控制这些对象特有的复<br>杂性?增加一层间接层是软件开发中常见的解决方式。</li></ol><h2 id="定义">定义</h2><blockquote><p>为其他对象提供一种代理以控制(隔离，使用接口)对这个对象的访问</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/11_01.png" alt="结构"></p><h2 id="例子">例子</h2><h3 id="传统">传统</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISubject</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span>:</span> <span class="keyword">public</span> ISubject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientApp</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    ISubject* subject;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">ClientApp</span>()&#123;</span><br><span class="line">        subject=<span class="keyword">new</span> <span class="built_in">RealSubject</span>();</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        subject-&gt;<span class="built_in">process</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="代理模式">代理模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISubject</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Proxy的设计</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span>:</span> <span class="keyword">public</span> ISubject&#123;  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//对RealSubject的一种间接访问</span></span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientApp</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    ISubject* subject;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">ClientApp</span>()&#123;</span><br><span class="line">        subject=<span class="keyword">new</span> <span class="built_in">SubjectProxy</span>();</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        subject-&gt;<span class="built_in">process</span>();      </span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>“增加一层间接层’是软件系统中对许多复杂问题的一种常见解决方法。在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的proxy对象便是解决这一问题的常用手段。</li><li>具体proxy设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如copy-on-write技术， 有些可能对组件模块提供抽象代理层,在架构层次对对象做proxy。</li><li>Proxy并不一定要求保持接口完整的一致性，只要能够实现间接控<br>制，有时候损及一些透明性是可以接受的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(九)-Façade</title>
      <link href="/2021/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10/"/>
      <url>/2021/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10/</url>
      
        <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><p><img src="/img/PatternDesign/10_01.png" alt="动机"></p><ol><li>上述A方案的问题在于组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。</li><li>如何简化外部客户程序和系统间的交互接口?如何将外部客户程<br>序的演化和内部子系统的变化之间的依赖相互解耦?</li></ol><h2 id="定义">定义</h2><blockquote><p>为子系统中的一-组接口提供一个**一致(稳定)**的界面,Façade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用(复用)</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/10_02.png" alt="结构"></p><h2 id="总结">总结</h2><ol><li>从客户程序的角度来看，Façade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种“解耦”的效果，内部子系统的任何变化不会影响到Façade接口的变化。</li><li>Façade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Façade很多时候更是一种架构设计模式。</li><li>Façade设计模式并非一个集装箱，可以任意地放进任何多个对象。Façade模式中组件的内部应该是“相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(八)-Flyweight</title>
      <link href="/2021/11/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F09/"/>
      <url>/2021/11/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F09/</url>
      
        <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价——主要指内存需求方面的代价。</li><li>在避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作</li></ol><h2 id="定义">定义</h2><blockquote><p>运用共享技术有效地支持大量细粒度的对象</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/09_01.png" alt="结构"></p><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//unique object key</span></span><br><span class="line">    string key;  </span><br><span class="line">    <span class="comment">//object state</span></span><br><span class="line">    <span class="comment">//....   </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Font</span>(<span class="keyword">const</span> string&amp; key)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FontFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;string,Font* &gt; fontPool;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Font* <span class="title">GetFont</span><span class="params">(<span class="keyword">const</span> string&amp; key)</span></span>&#123;</span><br><span class="line">        map&lt;string,Font*&gt;::iterator item=fontPool.<span class="built_in">find</span>(key);       </span><br><span class="line">        <span class="keyword">if</span>(item!=footPool.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> fontPool[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Font* font = <span class="keyword">new</span> <span class="built_in">Font</span>(key);</span><br><span class="line">            fontPool[key]= font;</span><br><span class="line">            <span class="keyword">return</span> font;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>面向对象很好地解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。</li><li>Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。</li><li>对象的数量太大从而导致对象内存开销加大——什么样的数量才算大?这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断。</li></ol><p><img src="/img/PatternDesign/PatternDesign09.png" alt="PatternDesign09"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(七)- Singleton</title>
      <link href="/2021/11/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F08/"/>
      <url>/2021/11/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F08/</url>
      
        <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。</li><li>绕过常规的构造器，提供一种机制来保证一个类只有一个实例</li><li>这是类设计者的责任，而不是使用者的责任。</li></ol><h2 id="定义">定义</h2><blockquote><p>保证一个类仅有一个实例，并提供一个该实例的全局访问点。</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/08_01.png" alt="结构"></p><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//单例模式只能有一个示例 因此需要阻止拷贝</span></span><br><span class="line">    <span class="comment">//拷贝构造函数、拷贝赋值运算符不需要</span></span><br><span class="line">    <span class="comment">//新标准加上delete可以定义为删除或定义为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态变量初始化</span></span><br><span class="line">Singleton* Singleton::m_instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程非安全版本</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程安全版,但锁的代价过高</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="keyword">if</span>(m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双检查锁 ，但由于内存读写reorder不安全</span></span><br><span class="line"><span class="comment">//只有为空才加锁，锁前不检查代价过高，锁后不检查线程不安全</span></span><br><span class="line"><span class="comment">//不要再用了</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Lock lock;</span><br><span class="line">        <span class="keyword">if</span>(m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c++11 版本之后的跨平台实现</span></span><br><span class="line">std::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class="line">std::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);<span class="comment">//获取内存fence</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);<span class="comment">//释放内存fence</span></span><br><span class="line">            m_instance.<span class="built_in">store</span>(tmp, std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用局部静态变量实现简洁的singleton写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//单例模式只能有一个示例 因此需要阻止拷贝</span></span><br><span class="line">    <span class="comment">//拷贝构造函数、拷贝赋值运算符不需要</span></span><br><span class="line">    <span class="comment">//新标准加上delete可以定义为删除或定义为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function">Singleton&amp; <span class="title">operator</span><span class="params">(<span class="keyword">const</span> Singleton&amp;)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton m_instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单线程下，正确。</li><li>C++11及以后的版本（如C++14）的多线程下，正确。</li><li>C++11之前的多线程下，不一定正确。原因在于在C++11之前的标准中并没有规定local static变量的内存模型。于是乎它就是不是线程安全的了。但是在C++11却是线程安全的，这是因为新的C++标准规定了当一个线程正在初始化一个变量的时候，其他线程必须得等到该初始化完成以后才能访问它。</li></ul><p>上述使用的内存序：</p><p>memory_order_relaxed：松散内存序，只用来保证对原子对象的操作是原子的<br>memory_order_acquire：获得操作，在读取某原子对象时，当前线程的任何后面的读写操作都不允许重排到这个操作的前面去，并且其他线程在对同一个原子对象释放之前的所有内存写入都在当前线程可见<br>memory_order_release：释放操作，在写入某原子对象时，当前线程的任何前面的读写操作都不允许重排到这个操作的后面去，并且当前线程的所有内存写入都在对同一个原子对象进行获取的其他线程可见</p><h2 id="总结">总结</h2><ol><li>Singleton模式中的实例构造器可以设置为protected以允许子类派生。</li><li>Singleton模式一般不要支持拷贝构造函数和Clone接口，因为这有可能导致多个对象实例，与Singleton模式的初衷违背。</li><li>如何实现多线程环境下安全的Singleton?注意对双检查锁的正确实现。</li></ol><p><img src="/img/PatternDesign/PatternDesign08.png" alt="PatternDesign08"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(六)- Factory</title>
      <link href="/2021/11/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F07/"/>
      <url>/2021/11/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F07/</url>
      
        <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在软件系统中,经常面临着创建对象的工作;由于需求的变化,需要创建的对象的具体类型经常变化</li><li>如何应对这种变化?如何绕过常规的对象创建方法(new)，提供一种“封装机制&quot;来避免客户程序和这种“具体对象创建工作&quot;的紧耦合?</li></ol><h2 id="定义">定义</h2><blockquote><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化<strong>延迟</strong>(目的:解耦，手段︰虚函数)到子类。</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/07_01.png" alt="结构"></p><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//product抽象类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ISplitter</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Creator工厂基类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplitterFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">SplitterFactory</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">    SplitterFactory*  factory;<span class="comment">//工厂</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainForm</span>(SplitterFactory*  factory)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;factory=factory;</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;   </span><br><span class="line">ISplitter * splitter=</span><br><span class="line">            factory-&gt;<span class="built_in">CreateSplitter</span>(); <span class="comment">//多态new    </span></span><br><span class="line">        splitter-&gt;<span class="built_in">split</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在完成产品类和对应的工厂类后，便可在<code>MainForm</code>中应用。可以保证编译时只依赖与产品基类和工厂单类。子类可以依据需求随时实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类的实现</span></span><br><span class="line"><span class="comment">//具体product</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span> :</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//具体工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BinarySplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TxtSplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。</li><li>Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改)的策略，较好地解决了这种紧耦合关系。</li><li>Factory Method模式解决“单个对象&quot;的需求变化。缺点在于要求创建方法/参数相同。</li></ol><p><img src="/img/PatternDesign/PatternDesign07.png" alt="PatternDesign07"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(五)- Birdge</title>
      <link href="/2021/11/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F06/"/>
      <url>/2021/11/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F06/</url>
      
        <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个纬度的变化</li><li>如何应对这种“多维度的变化”?如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度?</li></ol><h2 id="定义">定义</h2><blockquote><p>将抽象部分业务功能)与实现部分(平台实现)分离，使它们都可以独立地变化。</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/06_01.png" alt="结构"></p><h2 id="例子">例子</h2><h3 id="传统继承">传统继承</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Messager</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Messager</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//平台实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerBase</span> :</span> <span class="keyword">public</span> Messager&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerBase</span> :</span> <span class="keyword">public</span> Messager&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务抽象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerLite</span> :</span> <span class="keyword">public</span> PCMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerPerfect</span> :</span> <span class="keyword">public</span> PCMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerLite</span> :</span> <span class="keyword">public</span> MobileMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerPerfect</span> :</span> <span class="keyword">public</span> MobileMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//编译时装配</span></span><br><span class="line">        Messager *m =</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">MobileMessagerPerfect</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="桥模式">桥模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Messager</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">     MessagerImp* messagerImp;<span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Messager</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerImp</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">MessagerImp</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//平台实现 n</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerImp</span> :</span> <span class="keyword">public</span> MessagerImp&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerImp</span> :</span> <span class="keyword">public</span> MessagerImp&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//业务抽象 m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类的数目：1+n+m</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerLite</span> :</span><span class="keyword">public</span> Messager &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerPerfect</span>  :</span><span class="keyword">public</span> Messager &#123;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    MessagerImp* mImp=<span class="keyword">new</span> <span class="built_in">PCMessagerImp</span>();</span><br><span class="line">    Messager *m =<span class="keyword">new</span> <span class="built_in">Messager</span>(mImp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。</li><li>Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单职责原则(即一个类只有一个变化的原因)，复用性比较差。Bridge模式是比多继承方案更好的解决方法。</li><li>Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。</li></ol><p><img src="/img/PatternDesign/PatternDesign06.png" alt="PatternDesign06"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(五)- Decorator</title>
      <link href="/2021/11/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F05/"/>
      <url>/2021/11/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F05/</url>
      
        <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性;并且随着子类的增多(扩展功能的增多)，各种子类的组合(扩展功能的组合)会导致更多子类的膨胀。</li><li>如何使‘对象功能的扩展”能够根据需要来动态地实现?同时避免扩展功能的增多”带来的子类膨胀问题?从而使得任何“功能扩展变化”所导致的影响将为最低?</li></ol><h2 id="定义">定义</h2><blockquote><p>动态(组合)地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类(继承)更为灵活(消除重复代码&amp;减少子类个数)</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/05_01.png" alt="结构"></p><h2 id="例子">例子</h2><h3 id="传统">传统</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileStream</span>:</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoFileStream</span> :</span><span class="keyword">public</span> FileStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;       </span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Read</span>(number);<span class="comment">//读文件流        </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Seek</span>(position);<span class="comment">//定位文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Write</span>(data);<span class="comment">//写文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoNetworkStream</span> :</span> :<span class="keyword">public</span> NetworkStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;        </span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        NetworkStream::<span class="built_in">Read</span>(number);<span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        NetworkStream::<span class="built_in">Seek</span>(position);<span class="comment">//定位网络流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        NetworkStream::<span class="built_in">Write</span>(data);<span class="comment">//写网络流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoMemoryStream</span> :</span> <span class="keyword">public</span> MemoryStream&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedFileStream</span> :</span> <span class="keyword">public</span> FileStream&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedNetworkStream</span> :</span> <span class="keyword">public</span> NetworkStream&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedMemoryStream</span> :</span> <span class="keyword">public</span> MemoryStream&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoBufferedFileStream</span> :</span><span class="keyword">public</span> FileStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Read</span>(number);<span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Seek</span>(position);<span class="comment">//定位文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Write</span>(data);<span class="comment">//写文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//编译时装配</span></span><br><span class="line">    CryptoFileStream *fs1 = <span class="keyword">new</span> <span class="built_in">CryptoFileStream</span>();</span><br><span class="line"></span><br><span class="line">    BufferedFileStream *fs2 = <span class="keyword">new</span> <span class="built_in">BufferedFileStream</span>();</span><br><span class="line"></span><br><span class="line">    CryptoBufferedFileStream *fs3 =<span class="keyword">new</span> <span class="built_in">CryptoBufferedFileStream</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="装饰模式">装饰模式</h3><p>有时候组合方式会好于继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>=<span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileStream</span>:</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写网络流</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写内存流</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoStream</span>:</span> <span class="keyword">public</span> Stream &#123;</span><br><span class="line">    </span><br><span class="line">    Stream* stream;<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CryptoStream</span>(Stream* stm):<span class="built_in">stream</span>(stm)&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream-&gt;<span class="built_in">Read</span>(number);<span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Seek</span>(position);<span class="comment">//定位文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Write</span>(data);<span class="comment">//写文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedStream</span> :</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line">    </span><br><span class="line">    Stream* stream;<span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BufferedStream</span>(Stream* stm):<span class="built_in">stream</span>(stm)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    FileStream* s1=<span class="keyword">new</span> <span class="built_in">FileStream</span>();</span><br><span class="line">    CryptoStream* s2=<span class="keyword">new</span> <span class="built_in">CryptoStream</span>(s1);   </span><br><span class="line">    BufferedStream* s3=<span class="keyword">new</span> <span class="built_in">BufferedStream</span>(s1);</span><br><span class="line">    BufferedStream* s4=<span class="keyword">new</span> <span class="built_in">BufferedStream</span>(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/PatternDesign/05_03.png" alt="继承方式"><br>可以看出CryptoStream类和BufferedStream类都含有相同的Stream指针成员，可以继续向上合并</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileStream</span>:</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写网络流</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写内存流</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展操作</span></span><br><span class="line"></span><br><span class="line">DecoratorStream: <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Stream* stream;<span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DecoratorStream</span>(Stream * stm):<span class="built_in">stream</span>(stm)&#123;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoStream</span>:</span> <span class="keyword">public</span> DecoratorStream &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CryptoStream</span>(Stream* stm):<span class="built_in">DecoratorStream</span>(stm)&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;     </span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream-&gt;<span class="built_in">Read</span>(number);<span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Seek</span>(position);<span class="comment">//定位文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Write</span>(data);<span class="comment">//写文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedStream</span> :</span> <span class="keyword">public</span> DecoratorStream&#123;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BufferedStream</span>(Stream* stm):<span class="built_in">DecoratorStream</span>(stm)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    FileStream* s1=<span class="keyword">new</span> <span class="built_in">FileStream</span>();    </span><br><span class="line">    CryptoStream* s2=<span class="keyword">new</span> <span class="built_in">CryptoStream</span>(s1);    </span><br><span class="line">    BufferedStream* s3=<span class="keyword">new</span> <span class="built_in">BufferedStream</span>(s1);  </span><br><span class="line">    BufferedStream* s4=<span class="keyword">new</span> <span class="built_in">BufferedStream</span>(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li><p>通过采用组合而非继承的手法，Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差’’和“多子类衍生问题”。</p></li><li><p>Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。</p></li><li><p>Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”一是为“装饰”的含义</p></li></ol><p><img src="/img/PatternDesign/PatternDesign05.png" alt="结构"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(四)- Observer/Event</title>
      <link href="/2021/11/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F04/"/>
      <url>/2021/11/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F04/</url>
      
        <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在软件构建过程中,我们需要为某些对象建立一种 &quot;通知依赖关系”：一个对象(目标对象)的状态发生改变,所有的依赖对象(观察者对象)都将得到通知。如果这样的依赖关系过于紧密将使软件不能很好地抵御变化</li><li>使用面向对象技术,可以将这种依赖关系弱化,并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合</li></ol><h2 id="定义">定义</h2><blockquote><p>定义对象间的一种一对多(变化)的依赖关系,以便当一个对象(Subject)的状态发生改变时,所有依赖于它的对象都得到通知并自动更新</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/04_01.png" alt="结构"></p><h2 id="例子">例子</h2><h3 id="传统通知模式">传统通知模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FileSplitter1.cpp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSplitter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">string m_filePath;</span><br><span class="line"><span class="keyword">int</span> m_fileNumber;</span><br><span class="line">ProgressBar* m_progressBar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">FileSplitter</span>(<span class="keyword">const</span> string&amp; filePath, <span class="keyword">int</span> fileNumber, ProgressBar* progressBar) :</span><br><span class="line"><span class="built_in">m_filePath</span>(filePath), </span><br><span class="line"><span class="built_in">m_fileNumber</span>(fileNumber),</span><br><span class="line"><span class="built_in">m_progressBar</span>(progressBar)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.读取大文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.分批次向小文件中写入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_fileNumber; i++)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">float</span> progressValue = m_fileNumber;</span><br><span class="line">progressValue = (i + <span class="number">1</span>) / progressValue;</span><br><span class="line">m_progressBar-&gt;<span class="built_in">setValue</span>(progressValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainForm1.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">TextBox* txtFilePath;</span><br><span class="line">TextBox* txtFileNumber;</span><br><span class="line">ProgressBar* progressBar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">string filePath = txtFilePath-&gt;<span class="built_in">getText</span>();</span><br><span class="line"><span class="keyword">int</span> number = <span class="built_in">atoi</span>(txtFileNumber-&gt;<span class="built_in">getText</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="function">FileSplitter <span class="title">splitter</span><span class="params">(filePath, number, progressBar)</span></span>;</span><br><span class="line"></span><br><span class="line">splitter.<span class="built_in">split</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="观察者模式">观察者模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FileSplitter2.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IProgress</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoProgress</span><span class="params">(<span class="keyword">float</span> value)</span></span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">IProgress</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSplitter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">string m_filePath;</span><br><span class="line"><span class="keyword">int</span> m_fileNumber;</span><br><span class="line"></span><br><span class="line">List&lt;IProgress*&gt;  m_iprogressList; <span class="comment">// 抽象通知机制，支持多个观察者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">FileSplitter</span>(<span class="keyword">const</span> string&amp; filePath, <span class="keyword">int</span> fileNumber) :</span><br><span class="line"><span class="built_in">m_filePath</span>(filePath), </span><br><span class="line"><span class="built_in">m_fileNumber</span>(fileNumber)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.读取大文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.分批次向小文件中写入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_fileNumber; i++)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> progressValue = m_fileNumber;</span><br><span class="line">progressValue = (i + <span class="number">1</span>) / progressValue;</span><br><span class="line"><span class="built_in">onProgress</span>(progressValue);<span class="comment">//发送通知</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addIProgress</span><span class="params">(IProgress* iprogress)</span></span>&#123;</span><br><span class="line">m_iprogressList.<span class="built_in">push_back</span>(iprogress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeIProgress</span><span class="params">(IProgress* iprogress)</span></span>&#123;</span><br><span class="line">m_iprogressList.<span class="built_in">remove</span>(iprogress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onProgress</span><span class="params">(<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">List&lt;IProgress*&gt;::iterator itor=m_iprogressList.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (itor != m_iprogressList.<span class="built_in">end</span>() )</span><br><span class="line">(*itor)-&gt;<span class="built_in">DoProgress</span>(value); <span class="comment">//更新进度条</span></span><br><span class="line">itor++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainForm2.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承，From为主继承，继承通知基类只为使用其提供的接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form, <span class="keyword">public</span> IProgress</span><br><span class="line">&#123;</span><br><span class="line">TextBox* txtFilePath;</span><br><span class="line">TextBox* txtFileNumber;</span><br><span class="line"></span><br><span class="line">ProgressBar* progressBar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">string filePath = txtFilePath-&gt;<span class="built_in">getText</span>();</span><br><span class="line"><span class="keyword">int</span> number = <span class="built_in">atoi</span>(txtFileNumber-&gt;<span class="built_in">getText</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">ConsoleNotifier cn;</span><br><span class="line"></span><br><span class="line"><span class="function">FileSplitter <span class="title">splitter</span><span class="params">(filePath, number)</span></span>;</span><br><span class="line"></span><br><span class="line">splitter.<span class="built_in">addIProgress</span>(<span class="keyword">this</span>); </span><br><span class="line">splitter.<span class="built_in">addIProgress</span>(&amp;cn);</span><br><span class="line"></span><br><span class="line">splitter.<span class="built_in">split</span>();</span><br><span class="line"></span><br><span class="line">splitter.<span class="built_in">removeIProgress</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoProgress</span><span class="params">(<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line">progressBar-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleNotifier</span> :</span> <span class="keyword">public</span> IProgress &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoProgress</span><span class="params">(<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>使用面向对象的抽象, Observer模式使得我们可以独立地改变目标与观察者,从而使二者之间的依赖关系达致松耦合</li><li>目标发送通知时,无需指定观察者,通知(可以携带通知信息作为参数)会自动传播</li><li>观察者自己决定是否需要订阅通知,目标对象对此一无所知</li><li>Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分</li></ol><p><img src="/img/PatternDesign/PatternDesign04.png" alt="PatternDesign04"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(三)- Strategy</title>
      <link href="/2021/11/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F03/"/>
      <url>/2021/11/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F03/</url>
      
        <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>对象使用的算法多变，若都编码在对象中，使得对象复杂</li><li>运行时根据需要透明的更改对象算法，将算法与对象本身解耦</li></ol><h2 id="定义">定义</h2><blockquote><p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换((变化)。该模式使得算法可独立于使用它的客户程序稳定)而变化(扩展，子类化)。</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/03_01.png" alt="结构"></p><h2 id="例子">例子</h2><h3 id="传统分而治之">传统分而治之</h3><p>采用大量的if-else语句进行情况的选择，在编译阶段代码无法实现复用。每次需要增添一种货币的计算方式时，都必须在源代码下方增添if-else来实现相关策略的选择</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TaxBase</span> &#123;</span></span><br><span class="line">CN_Tax,</span><br><span class="line">US_Tax,</span><br><span class="line">DE_Tax,</span><br><span class="line">FR_Tax       <span class="comment">//¸ü¸Ä</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesOrder</span>&#123;</span></span><br><span class="line">    TaxBase tax;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (tax == CN_Tax)&#123;</span><br><span class="line">            <span class="comment">//CN***********</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tax == US_Tax)&#123;</span><br><span class="line">            <span class="comment">//US***********</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tax == DE_Tax)&#123;</span><br><span class="line">            <span class="comment">//DE***********</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tax == FR_Tax)&#123;  <span class="comment">//¸ü¸Ä</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="采用策略模式">采用策略模式</h3><p>构建策略基类，所有真实情况的货币类都是该策略基类的派生类，利用多态机制实现策略的选择</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//策略基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaxStrategy</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//虚函数 提供策略接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TaxStrategy</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//针对自身提供与之相对的策略</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DETax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对新增的FRTax,只需要重新派生该类并定义相关算法即可</span></span><br><span class="line"><span class="comment">//*********************************</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FRTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line"><span class="comment">//.........</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现策略接口的调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesOrder</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaxStrategy* strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SalesOrder</span>(StrategyFactory* strategyFactory)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;strategy = strategyFactory-&gt;<span class="built_in">NewStrategy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SalesOrder</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="function">Context <span class="title">context</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> val = </span><br><span class="line">            strategy-&gt;<span class="built_in">Calculate</span>(context); </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li><p>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。</p></li><li><p>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语苟，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。(如果if-else是绝对稳定不变的，不太需要strategy模式)</p></li><li><p>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。</p></li></ol><p><img src="/img/PatternDesign/PatternDesign03.png" alt="PatternDesign03"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(二)- Template Mothod</title>
      <link href="/2021/11/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F02/"/>
      <url>/2021/11/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F02/</url>
      
        <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li><p>有稳定的整体结构，但各个子步骤有改变的需求</p></li><li><p>在确认稳定操作结构前提下，灵活应对各个子步骤的变化和晚期实现需求</p></li></ol><h2 id="定义">定义</h2><blockquote><p>定义一个操作中的算法的骨架(稳定),而将一些步骤延迟(变化)到子类中。Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(override重写)该算法的某些特定步骤。</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/02_03.png" alt="结构"></p><h2 id="例子">例子</h2><h3 id="结构化软件设计流程-早绑定">结构化软件设计流程(早绑定)</h3><p><img src="/img/PatternDesign/02_01.png" alt="结构化软件设计流程"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Library</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Step1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Step3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Step5</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Step4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Library <span class="title">lib</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Application <span class="title">app</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">lib.<span class="built_in">Step1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (app.<span class="built_in">Step2</span>())&#123;</span><br><span class="line">lib.<span class="built_in">Step3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">app.<span class="built_in">Step4</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lib.<span class="built_in">Step5</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模版方法设计流程-晚绑定">模版方法设计流程(晚绑定)</h3><p><img src="/img/PatternDesign/02_02.png" alt="模版方法设计流程"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib.cpp</span></span><br><span class="line"><span class="comment">//程序库开发人员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Library</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//稳定 template method</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Step1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Step2</span>()) &#123; <span class="comment">//支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class="line">            <span class="built_in">Step3</span>(); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">Step4</span>(); <span class="comment">//支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Step5</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Library</span>()&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Step1</span><span class="params">()</span> </span>&#123; <span class="comment">//稳定</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Step3</span><span class="params">()</span> </span>&#123;<span class="comment">//稳定</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Step5</span><span class="params">()</span> </span>&#123; <span class="comment">//稳定</span></span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//变化</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Step4</span><span class="params">()</span> </span>=<span class="number">0</span>; <span class="comment">//变化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.cpp</span></span><br><span class="line"><span class="comment">//应用程序开发人员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> :</span> <span class="keyword">public</span> Library &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//... 子类重写实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Step4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//... 子类重写实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Library* pLib=<span class="keyword">new</span> <span class="built_in">Application</span>();</span><br><span class="line">    lib-&gt;<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pLib;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>Template Method模式是一 -种非常基础性的设计模式,在面向对象系统中有着大量的应用。它用最简洁的机制(虚函数的多态性)为很多应用程序框架提供了灵活的扩展点,是代码复用方面的基本实现结构</li><li>除了可以灵活应对子步骤的变化外，“不要调用我,让我来调用尔”的反向控制结构是Template Method的典型应用。</li><li>在具体实现方面,被Template Method调用的虚方法可以具有实现,也可以没有任何实现(抽象方法、纯虚方法) ,但一般推荐将它们设置为protected方法。<br><img src="/img/PatternDesign/PatternDesign02.png" alt="PatternDesign02"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(一)-面向对象设计原则</title>
      <link href="/2021/11/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F01/"/>
      <url>/2021/11/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F01/</url>
      
        <content type="html"><![CDATA[<h2 id="认识面向对象">认识面向对象</h2><h3 id="理解隔离变化：面向对象的构建方式更能适应软件需求的变化，降低变化带来的影响">理解隔离变化：面向对象的构建方式更能适应软件需求的变化，降低变化带来的影响</h3><h3 id="各司其职">各司其职</h3><ul><li>新增类型不应该影响原来类型的实现</li></ul><h3 id="何为对象">何为对象</h3><ul><li>语言层次：对象封装了代码和数据</li><li>规格层次：对象是可被使用的公共接口</li><li>概念层次：对象是某种拥有任务的抽象</li></ul><h2 id="八大设计原则">八大设计原则</h2><h3 id="依赖倒置原则DIP">依赖倒置原则DIP</h3><ul><li>高层模块(稳定)不应该依赖与底层模块(变化),都应该依赖于抽象(稳定)</li><li>抽象(稳定)不依赖于实现细节，实现细节依赖于抽象(稳定)</li></ul><h3 id="开放封闭原则OCP">开放封闭原则OCP</h3><ul><li>对扩展开放，对更改封闭</li><li>类模块应该是可扩展的，但不可修改</li></ul><h3 id="单一职责原则SRP">单一职责原则SRP</h3><ul><li>一个类应该仅有一个引起它变化的原因</li><li>变化的方向隐含累的责任</li></ul><h3 id="Liskov替换原则">Liskov替换原则</h3><ul><li>子类必须能够替换他们的基类(IS A)</li><li>继承表达类型抽象</li></ul><h3 id="接口隔离原则-ISP">接口隔离原则(ISP)</h3><ul><li>接口小而完备</li><li>不应该强迫客户程序依赖他们不用的方法</li></ul><h3 id="优先使用对象组合，而不是类继承">优先使用对象组合，而不是类继承</h3><ul><li>类继承通常维白箱复用，对象组合通常为黑箱复用</li><li>继承在某种程度上破坏了封装性，子类父类耦合高</li><li>面对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li></ul><h3 id="封装变化点">封装变化点</h3><ul><li>使用封装来创建对象之间的分界层,让设计者可以在分界层一侧进行修改,而不会对另一侧产生不良的影响,从而实现层次间的松耦合。</li></ul><h3 id="针对接口编程，而非针对实现编程">针对接口编程，而非针对实现编程</h3><ul><li>客户程序无需获知对象的具体类型,只需要知道对象所具有的接口</li><li>不将变量类型声明为某个特定的具体类,而是声明为某个接口</li><li>减少系统中各部分的依赖关系,从而实现&quot;高内聚、松耦合”的类型设计方案</li></ul><p><img src="/img/PatternDesign/PatternDesign01.png" alt="面向对象设计原则"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++Primer读书笔记(一)-访问控制与继承</title>
      <link href="/2021/10/27/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
      <url>/2021/10/27/C-Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>​每个类通过成员<strong>访问运算符</strong>控制其成员对于派生类和类的用户来说是否是可访问的。</p><h3 id="受保护的成员">受保护的成员</h3><p>​一个类使用<code>protected</code>关键字来声明那些希望与派生类分享但不想被其他用户访问的成员。可以说protected是夹在private成员和public成员的中和产物。主要有以下三条性质</p><ol><li>受保护成员对于类的用户者不可访问</li><li>受保护成员对于派生类的成员和友元是可访问</li><li>派生类的成员或者友元只能通过<strong>派生类对象</strong>来访问基类的受保护成员，派生类对于一个<strong>基类对象</strong>中的受保护成员没有访问权限。即派生类的成员和友元只能访问<u>派生类对象中的基类部分的受保护成员</u>(管好自家)，而对一个普通基类对象中的受保护成员是没有访问权限的。</li></ol><p>第三点举例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;<span class="comment">//能访问Sneaky::prot_mem</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;   <span class="comment">//不能访问Base::proe_mem 对于一个基类对象中的受保护成员没有访问权限</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th style="text-align:center">类本身</th><th style="text-align:center">类的实例化对象(类的用户)</th><th style="text-align:center">类的派生</th></tr></thead><tbody><tr><td>public成员</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>private成员</td><td style="text-align:center">√</td><td style="text-align:center">X</td><td style="text-align:center">X</td></tr><tr><td>protected成员</td><td style="text-align:center">√</td><td style="text-align:center">X</td><td style="text-align:center">√</td></tr></tbody></table><p>√表示可访问，X表示不可访问</p><h3 id="三种继承方式——公有、私有和受保护继承">三种继承方式——公有、私有和受保护继承</h3><p>​不加声明，class默认私有继承，struct默认公有继承</p><p>​类对其继承而来的成员的访问权限收到两个因素影响：1.基类中的成员访问符 2. 派生列表的访问说明符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> priv_mem;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> prop_men;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义公有派生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pub_Derv</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="comment">//正确，可访问基类部分的受保护成员</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> prop_men;&#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//错误，不能访问基类部分的私有成员</span></span><br><span class="line">  <span class="comment">//char g()&#123;return priv_mem;&#125;    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义私有派生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pri_Derv</span>:</span><span class="keyword">private</span> Base&#123;</span><br><span class="line">  <span class="comment">//正确，派生列表中访问说明符不影响派生类对于基类部分的访问权限</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> prop_men;&#125;      </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​派生列表的访问说明符不影响派生类对基类部分成员的访问权限，这只与基类中的成员访问符有关，派生列表中的访问说明符的目的是</p><p>控制派生类用户(包括派生类的派生)对于<strong>基类成员</strong>的访问权限</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pub_Derv d1;</span><br><span class="line">Pri_Derv d2;</span><br><span class="line">d1.<span class="built_in">pub_mem</span>();<span class="comment">//正确</span></span><br><span class="line"><span class="comment">//d2.pub_mem()  //错误，经过私有继承后，基类中的公有成员对于派生类用户不可访问</span></span><br></pre></td></tr></table></figure><h3 id="派生类向基类转换的可访问性">派生类向基类转换的可访问性</h3><p>派生类向基类转换: 基类的指针指向派生类或者基类的引用绑定到派生类对象(实际上是指向或者绑定到派生类的基类部分)</p><ul><li>只有当派生类公有的继承基类，<strong>用户代码</strong>才能使用派生类向基类转换。私有和保护继承都不行</li><li>派生类的<strong>成员函数和友元</strong>都能使用派生类向基类的转换，与继承方式无关</li><li>如果派生类是公有或者保护继承基类，那么派生类的派生类的成员函数和友元可以实现派生类向其基类的转换</li></ul><p>类的设计小tip</p><p>​类有三种用户：类的实现者、派生类以及类的使用者。基类应该将接口成员声明为公有；同时将实现部分分成两组：1.声明为<code>protected</code>供派生类访问 2. 声明为<code>private</code>共基类自身和基类的友元访问</p><table><thead><tr><th>类的用户</th><th>访问权限</th></tr></thead><tbody><tr><td>类的实现者</td><td>全部</td></tr><tr><td>类的使用者</td><td>类的公共接口</td></tr><tr><td>派生类</td><td>类的保护成员</td></tr></tbody></table><h3 id="友元与继承">友元与继承</h3><p>​友元关系不能传递也不能继承，<strong>每个类负责自己的成员的访问权限</strong>。基类的友元只能访问基类，不能访问它的派生类本身成员，但是可以访问派生类中的基类部分的成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span><span class="comment">//友元声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(Base b)</span></span>&#123;<span class="keyword">return</span> b.prot_mem;&#125;<span class="comment">//正确</span></span><br><span class="line"><span class="comment">//int f2(Sneaky s)&#123;return s.j;&#125;//错误 不能访问派生类本身成员</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">(Sneaky s)</span></span>&#123;<span class="keyword">return</span> s.prot_mem;&#125; <span class="comment">//正确,可以访问派生类中的基类部分的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++Primer读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MoreEffectiveC++(一)</title>
      <link href="/2021/10/26/MoreEffectiveC/"/>
      <url>/2021/10/26/MoreEffectiveC/</url>
      
        <content type="html"><![CDATA[<h1>一、基础 Basics</h1><h2 id="条款1-指针-pointer-与引用-reference-的选择">条款1 指针(pointer)与引用(reference)的选择</h2><p>1.pointer可以为空，但reference不能</p><p>因此对于一个变量如果总是代表一个对象，则应该该考虑为reference</p><p>且使用reference不需要测试其有效性，效率更高。使用pointer前需判断是否为空</p><p>2.pointer可以重新被赋值，但reference总是代表初始化的对象</p><p>当存在不指向任何对象或者指向对象有变化时应该使用pointer</p><p>3.在实现操作符重载是，常常返回类型为reference，可以作为左值</p><h2 id="条款2-使用c-转型操作符">条款2 使用c++转型操作符</h2><p>4个新的转型操作符(cast operators):<code>static_cast,const_cast,dynamic_cast,reinterpret_cast</code></p><p>写法为: <code>static_cast&lt;type&gt;(expression)</code> 注意在<code>static_cast&lt;vector&lt;int&gt; &gt;</code>最后两个<code>&gt;</code>最好有空格，防止编译器认为是<code>&gt;&gt;</code></p><table><thead><tr><th style="text-align:left">操作符</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>static_cast</code></td><td>用于基本的类型转换</td><td>不涉及继承机制</td></tr><tr><td style="text-align:left"><code>const_cast</code></td><td>用于改变表达式的常量属性，去掉const性质</td><td></td></tr><tr><td style="text-align:left"><code>dynamic_cast</code></td><td>用于执行继承体系中安全向下或者跨系转型动作(将指向base的指针转换成指向derived)</td><td>对于pointer，失败返回null，对于reference，失败返回exception；只能协助巡航在继承体系中，无法应用在缺乏虚函数的类型上</td></tr><tr><td style="text-align:left"><code>reinterpret_cast</code></td><td>最常用于转换“函数指针”</td><td>与编译平台有关，不具有移植性</td></tr></tbody></table><h2 id="条款3-不以多态方式处理数组">条款3 不以多态方式处理数组</h2><p>对于数组<code>array</code>，数组名也为首地址。<code>array[i]</code> === <code>*(array+i)</code></p><p><code>array</code>与<code>array+i</code>内存之间的距离一定是<code>i*sizeof(item)</code></p><p>编译器对于数组中对象的大小在声明时定下，导致多态时是无法正确定位实际的内存距离</p><h2 id="条款4-非必要不提供默认构造函数">条款4 非必要不提供默认构造函数</h2><p>不提供默认构造函数会带来一下三点的不便</p><ul><li>不能产生类对象的数组(解决方法：1，non-heap数组，提前给定初始化的变量 2指针数组 3，<code>placement new</code>方式)</li><li>不适用于基于模板的容器类，因为被实例化的<strong>目标类型</strong>需要一个默认构造函数</li><li>虚基类不提供默认构造函数，派生类必须提供初始化参数</li></ul><p>然而，如果含有无意义成员变量的对象存在如果可以生存，那么对于大部分的成员函数都必须检测该成员变量，降低效率。</p><p>如果类的构造函数能够保证对象的所有字段都被正确初始哈，那么这些测试代码、对于的处理程序所带来的时间和空间的代价可以免除，</p><p>显然，默认构造函数无法带来这样的保证，那么<strong>最好避免</strong>让默认构造函数出现。</p><h1>二、操作符 Operators</h1><h2 id="条款5-对定制的“类型转化函数”保持警觉">条款5 对定制的“类型转化函数”保持警觉</h2><p>当存在以下条件之一，便有可能发生隐式类型转换</p><ul><li>含有单自变量构造函数。能以单一变量成功初始化对象(利用关键词<code>explicit</code>阻止隐式转换,或采用proxy class)</li><li>成员函数含有隐式类型操作函数。如 operator double()const;</li></ul><p>最好不提供任何类型转换函数，问题在于此类函数的调用可能超出你的预期，结果可能是不正确，不直观并且难以调试。</p><p>例子：</p><p>标准库程序string类并未含有**从string对象到C风格char*的隐式转换函数 **，而是需要显示调用<code>c_str</code>成员函数来执行这种转化行为</p><h2 id="条款6-自增自减操作符的前置与后置">条款6 自增自减操作符的前置与后置</h2><p>自增自减的重载，为了区别前置与后置只好让后置有一个int形参，编译器默认指定为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPInt</span>&#123;</span></span><br><span class="line">    UPInt&amp; <span class="keyword">operator</span>++();<span class="comment">//前置++</span></span><br><span class="line">    <span class="keyword">const</span> UPInt <span class="keyword">operator</span>++(<span class="keyword">int</span>);<span class="comment">//后置++</span></span><br><span class="line">&#125;;</span><br><span class="line"> UPInt&amp; UPInt::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">     *<span class="keyword">this</span> +=<span class="number">1</span>;     <span class="comment">//累加</span></span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//取出</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">const</span> UPInt UPInt::<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">    UPInt oldValue = *<span class="keyword">this</span>; <span class="comment">//取出</span></span><br><span class="line">    ++(*<span class="keyword">this</span>);<span class="comment">//累加</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前置：increment and fetch 累加然后取出，返回值是引用</p><p>后置：fetch and increment 取出然后累加，返回值是一个const常量(防止i++++出现，毫无意义)</p><p><strong>尽可能使用前置式</strong>  原因在于</p><ul><li>后置式会产生临时变量</li><li>后置式一般是以前置式为基础上实现的</li></ul><h2 id="条款7-不要重载-操作符">条款7 不要重载<code>&amp;&amp;</code>,<code>||</code>,<code>,</code>操作符</h2><p>c++对于真假表达式采用<strong>骤死式</strong>的评估方式。一旦该表达式的真假值确定后，剩余部分将不再进行计算。</p><p>即使c++允许我们重载，但是<strong>函数调用式</strong>会取代<strong>骤死式</strong>，这有悖游戏规则</p><p>如将<code>&amp;&amp;</code>重载，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(expr1 &amp;&amp; expr2)</span><br><span class="line">;</span><br><span class="line"><span class="comment">//实际编译是下列两者之一</span></span><br><span class="line"><span class="keyword">if</span>(expr1.<span class="keyword">operator</span>&amp;&amp;(expr2))  <span class="comment">//成员函数形式</span></span><br><span class="line">    ;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">operator</span>&amp;&amp;(expr1,expr2))  <span class="comment">//全局函数形式</span></span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>操作符重载的目的是让程序更容易被阅读，被撰写，被理解，而不是<s>炫技</s>或者<s>夸耀</s></p><h2 id="条款8-了解new与delete">条款8 了解<code>new</code>与<code>delete</code></h2><h1>三、 异常Exceptions</h1><h2 id="条款9-利用析构函数避免泄漏资源">条款9 利用析构函数避免泄漏资源</h2><p>实质上就是采用智能指针，不必担心内存泄漏</p><p>把资源(一般是指针)封装在对象中(如智能指针这种对象)，利用这种对象的析构函数避免资源泄露</p><h2 id="条款10-在构造函数内组织资源泄露">条款10 在构造函数内组织资源泄露</h2><p>虽然可以在析构函数中进行资源释放，然而如果异常发生在对象的构造阶段，便不可行。</p><p>原因是<u><strong>c++只会析构已构造完成的对象</strong></u>，这种机理的理由在于避免额外开销：如果需要析构未完成构造的对象，必然要记录下构造函数进行到什么程度，这势必会造成额外开销。</p><p>对于指针成员变量，一律采用智能指针可有效的避免资源泄露</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git之ssh连接多个远程仓库</title>
      <link href="/2021/10/21/Git%E4%B9%8Bssh%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
      <url>/2021/10/21/Git%E4%B9%8Bssh%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h3 id="本地仓库ssh连接多个远程仓库">本地仓库ssh连接多个远程仓库</h3><p>由于GitHub不同的两个账户不可以配置相同的公钥，因此本地仓库ssh连接多个远程仓库必须生成不同的密钥</p><h4 id="1-生成密钥">1.生成密钥</h4><p>对于使用ssh连接远程仓库，需要生成非对称密钥并将公钥添加到远程仓库中</p><pre><code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ssh-keygen -t rsa -f ~/.ssh/&lt;filename&gt; -C &quot;yourmail@xxx.com&quot;</span><br></pre></td></tr></table></figure></code></pre><p>通常<code>id_rsa</code>和<code>id_rsa.pub</code>是默认密钥，额外生成的密钥需要自定义</p><h4 id="2-配置ssh的config">2.配置ssh的config</h4><ol><li><p>创建config文件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">touch config</span><br><span class="line">vim config</span><br></pre></td></tr></table></figure></li><li><p>编辑配置文件，使不同密钥指向不同远程仓库</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一个账号，默认使用的账号</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二个账号</span></span><br><span class="line">Host second.github.com  # second为前缀名，可以任意设置</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/&lt;filename&gt;</span><br></pre></td></tr></table></figure></li><li><p>清空本地缓存，添加新的ssh密钥到SSH agenth中</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -D</span><br><span class="line">ssh-add id_rsa</span><br><span class="line">ssh-add &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>原理分析<br>1.ssh 客户端是通过类似 <a href="mailto:git@github.com">git@github.com</a>:githubUserName/repoName.git ** 的地址来识别使用本地的哪个私钥的，地址中的 User 是@前面的git， Host 是@后面的github.com。<br>2.如果所有账号的 User 和 Host 都为 git 和 <a href="http://github.com">github.com</a>，那么就只能使用一个私钥。所以要对User 和 Host 进行配置，让每个账号使用自己的 Host，每个 Host 的域名做 CNAME 解析到 <a href="http://github.com">github.com</a>，如上面配置中的Host <a href="http://second.github.com">second.github.com</a>。<br>3.配置了别名之后，新的地址就是git@second.github.com:githubUserName/repName.git**（在添加远程仓库时使用）。<br>这样 ssh 在连接时就可以区别不同的账号了</p></li><li><p>测试ssh链接</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">ssh -T git@second.github.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> xxx! You’ve successfully authenticated, but GitHub does not provide bash access.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 出现上述提示，连接成功</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="3-仓库配置">3. 仓库配置</h4><ol><li><p>设置远程仓库即可，注意对应，比如说<filename>这个公钥放在了第二个仓库，就要注意修改host</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;remotename&gt; git@second.github.com:githubUserName/repName.git</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows终端代理</title>
      <link href="/2021/10/21/Windows%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86/"/>
      <url>/2021/10/21/Windows%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="临时生效">临时生效</h3><ol><li>获得代理服务器的使用的<strong>端口号</strong>和<strong>代理协议</strong><br><img src="/img/v2ray_proxy.png" alt="v2ray_proxy.png"></li><li>在cmd中设置环境变量</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用sock5代理</span></span><br><span class="line">set http_proxy=socks5://127.0.0.1:10808</span><br><span class="line">set https_proxy=socks5://127.0.0.1:10808</span><br></pre></td></tr></table></figure><h3 id="永久生效">永久生效</h3><p>若要永久生效，在系统中设置环境变量即可<br><img src="/img/sysenv.jpg" alt="sysenv.jpg"></p><h3 id="测试">测试</h3><p>重启cmd命令行，使用 curl <a href="http://www.google.com">www.google.com</a> ，如果有内容返回，说明设置成功（不可以是 <strong>ping</strong> 命令进行测试，不走http协议！！）</p>]]></content>
      
      
      <categories>
          
          <category> proxy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&gt;/dev/null 2&gt;&amp;1详解</title>
      <link href="/2021/10/19/dev-null-2-1%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/10/19/dev-null-2-1%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="1-shell输入输出重定向">1.shell输入输出重定向</h3><p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回​​到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p><ul><li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li></ul><p>重定向命令列表如下：</p><table><thead><tr><th style="text-align:left">命令</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">command &gt; file</td><td>将输出重定向到 file。</td></tr><tr><td style="text-align:left">command &lt; file</td><td>将输入重定向到 file。</td></tr><tr><td style="text-align:left">command &gt;&gt; file</td><td>将输出以追加的方式重定向到 file。</td></tr><tr><td style="text-align:left">n &gt; file</td><td>将文件描述符为 n 的文件重定向到 file。</td></tr><tr><td style="text-align:left">n &gt;&gt; file</td><td>将文件描述符为 n 的文件以追加的方式重定向到 file。</td></tr><tr><td style="text-align:left">n &gt;&amp; m</td><td>将输出文件 m 和 n 合并。</td></tr><tr><td style="text-align:left">n &lt;&amp; m</td><td>将输入文件 m 和 n 合并。</td></tr><tr><td style="text-align:left">&lt;&lt; tag</td><td>将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td></tr></tbody></table><h3 id="2-dev-null-文件">2./dev/null 文件</h3><p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&quot;禁止输出&quot;的效果。如果希望屏蔽stdout 和stderr,可以这样写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p><p>这里的 2 和 &gt; 之间不可以有空格，2&gt; 是一体的时候才表示错误输出。</p><h3 id="3-dev-null-2-1详解">3./dev/null 2&gt;&amp;1详解</h3><p>&amp; 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1</p><p>1 表示stdout标准输出，系统默认值是1，所以&quot;&gt;/dev/null&quot;等同于 “1&gt;/dev/null”</p><p>那么/dev/null 2&gt;&amp;1语句执行过程为：</p><p><code>1&gt;/dev/null </code>：首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。</p><p><code>2&gt;&amp;1 </code>：接着，标准错误输出重定向 到 标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件</p><p>最常用的方式有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command &gt; file 2&gt;file</span><br><span class="line"></span><br><span class="line">command &gt; file 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>不同之处<br>1.command &gt; file 2&gt;file 的意思是将命令所产生的标准输出信息,和错误的输出信息送到file 中.command &gt; file 2&gt;file 这样的写法,stdout和stderr都直接送到file中, file会被打开两次,这样stdout和stderr会互相覆盖,这样写相当使用了FD1和FD2两个同时去抢占file 的管道。<br>2.command &gt;file 2&gt;&amp;1 这条命令就将stdout直接送向file, stderr 继承了FD1管道后,再被送往file,此时,file 只被打开了一次,也只使用了一个管道FD1,它包括了stdout和stderr的内容。</p><p>从IO效率上,前一条命令的效率要比后面一条的命令效率要低所以在编写shell脚本的时候,较多的时候我们会command &gt; file 2&gt;&amp;1 这样的写法。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Producer-consumer problem</title>
      <link href="/2021/10/19/Producer-consumer%20problem/"/>
      <url>/2021/10/19/Producer-consumer%20problem/</url>
      
        <content type="html"><![CDATA[<h3 id="1-进程同步与信号量">1.进程同步与信号量</h3><p>进程同步:让多个进程&quot;走走停停&quot;来保证多进程合作的合理有序(以生产者消费者问题为例进行讲解)</p><h4 id="1-1生产者消费者问题">1.1生产者消费者问题</h4><p><strong>生产者消费者问题</strong>（英语：Producer-consumer problem），也称<strong>有限缓冲问题</strong>（Bounded-buffer problem），是一个<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E8%BF%9B%E7%A8%8B">多进程</a><a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%AD%A5">同步</a>问题的经典案例。该问题描述了共享固定大小<a href="https://zh.wikipedia.org/wiki/%E7%BC%93%E5%86%B2%E5%8C%BA">缓冲区</a>的两个进程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p><p>要解决该问题，就必须让生产者在缓冲区满时休眠（要么干脆就放弃数据），等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。通常采用<a href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1">进程间通信</a>的方法解决该问题，常用的方法有<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%8F%B7%E9%87%8F">信号灯法</a>[<a href="https://zh.wikipedia.org/zh-hans/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98#cite_note-1">1]</a>等。如果解决方法不够完善，则容易出现死锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己。该问题也能被推广到多个生产者和消费者的情形。</p><h4 id="1-2实现">1.2实现</h4><h5 id="1-2-1不完善实现">1.2.1不完善实现</h5>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> itemCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">procedure <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        item = <span class="built_in">produceItem</span>();</span><br><span class="line">      <span class="comment">//缓存区满，生产者休眠</span></span><br><span class="line">        <span class="keyword">if</span> (itemCount == BUFFER_SIZE) &#123;</span><br><span class="line">            <span class="built_in">sleep</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putItemIntoBuffer</span>(item);</span><br><span class="line">        itemCount = itemCount + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//缓存区数量为1，唤醒消费者</span></span><br><span class="line">        <span class="keyword">if</span> (itemCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">wakeup</span>(consumer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">procedure <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">//缓存区空，消费者休眠</span></span><br><span class="line">        <span class="keyword">if</span> (itemCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">sleep</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        item = <span class="built_in">removeItemFromBuffer</span>();</span><br><span class="line">        itemCount = itemCount - <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//缓存区数量为BUFFER_SIZE - 1，唤醒生产者</span></span><br><span class="line">        <span class="keyword">if</span> (itemCount == BUFFER_SIZE - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">wakeup</span>(producer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">consumeItem</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在的问题：可能导致竞争条件，进而引发死锁，如以下情况</p><ol><li>消费者把最后一个 itemCount 的内容读出来，注意它现在是零。消费者返回到while的起始处，现在进入 if 块；</li><li>就在调用sleep之前，CPU决定将时间让给生产者，于是消费者在执行 sleep 之前就被中断了，生产者开始执行；</li><li>生产者生产出一项数据后将其放入缓冲区，然后在 itemCount 上加 1；</li><li>由于缓冲区在上一步加 1 之前为空，生产者尝试唤醒消费者；</li><li>遗憾的是，消费者并没有在休眠，唤醒指令不起作用。当消费者恢复执行的时候，执行 sleep，一觉不醒。出现这种情况的原因在于，消费者只能被生产者在 itemCount 为 1 的情况下唤醒；</li><li>生产者不停地循环执行，直到缓冲区满，随后进入休眠。</li></ol><p>如果存在多个生产者，也是不行的，itemCount含义不足以表达休眠中的生产者。会存在有些生产者一直休眠</p><p><img src="/img/image-20210919131635850.png" alt="image-20210919131635850"></p><h5 id="1-2-2采取信号灯实现">1.2.2采取信号灯实现</h5><p>信号灯可以避免上述唤醒指令不起作用的情况。该方法使用了两个信号灯，fillCount 和 emptyCount。fillCount 用于记录缓冲区中将被读取的数据项数（实际上就是有多少数据项在缓冲区里），emptyCount 用于记录缓冲区中空闲空间数。当有新数据项被放入缓冲区时，fillCount 增加，emptyCount 减少。如果在生产者尝试减少 <strong>emptyCount 的时候发现其值为零，那么生产者就进入休眠</strong>。等到有数据项被消耗，emptyCount 增加的时候，生产者才被唤醒。消费者的行为类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">semaphore fillCount = <span class="number">0</span>; <span class="comment">// 生产的项目</span></span><br><span class="line">semaphore emptyCount = BUFFER_SIZE; <span class="comment">// 剩余空间</span></span><br><span class="line"></span><br><span class="line"><span class="function">procedure <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        item = <span class="built_in">produceItem</span>();</span><br><span class="line">        <span class="built_in">down</span>(emptyCount);</span><br><span class="line">      <span class="comment">//若emptyCount为0，生产者进入休眠</span></span><br><span class="line">      <span class="comment">//若emotyCount为负数，表示有生产者在休眠</span></span><br><span class="line">        <span class="built_in">putItemIntoBuffer</span>(item);</span><br><span class="line">        <span class="built_in">up</span>(fillCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">procedure <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">down</span>(fillCount);</span><br><span class="line">        item = <span class="built_in">removeItemFromBuffer</span>();</span><br><span class="line">        <span class="built_in">up</span>(emptyCount);</span><br><span class="line">        <span class="built_in">consumeItem</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法在只有一个生产者和一个消费者时能解决问题。对于多个生产者或者多个消费者共享缓冲区的情况，该算法也会导致竞争条件，出现两个或以上的进程同时读或写同一个缓冲区槽的情况。</p><p>为了说明这种情况是如何发生的，可以假设 putItemIntoBuffer() 的一种可能的实现：先寻找下一个可用空槽，然后写入数据项。下列情形是可能出现的：</p><ol><li>两个生产者都减少 emptyCount 的值；</li><li>某一生产者寻找到下一个可用空槽；</li><li>另一生产者也找到了下一个可用空槽，结果和上一步被找到的是同一个空槽；</li><li>两个生产者向可用空槽写入数据。</li></ol><p>为了解决这个问题，需要在保证同一时刻只有一个生产者能够执行 putItemIntoBuffer()。也就是说，需要寻找一种方法来互斥地执行临界区的代码。为了达到这个目的，可引入一个二值信号灯 mutex，其值只能为 1 或者 0。如果把线程放入 down(mutex) 和 up(mutex) 之间，就可以限制只有一个线程能被执行。多生产者、消费者的解决算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//只有mutex为1才允许进入修改共享缓冲区</span></span><br><span class="line">semaphore fillCount = <span class="number">0</span>;</span><br><span class="line">semaphore emptyCount = BUFFER_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="function">procedure <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        item = <span class="built_in">produceItem</span>();</span><br><span class="line">        <span class="built_in">down</span>(emptyCount);</span><br><span class="line">        <span class="built_in">down</span>(mutex);</span><br><span class="line">        <span class="built_in">putItemIntoBuffer</span>(item);</span><br><span class="line">        <span class="built_in">up</span>(mutex);</span><br><span class="line">        <span class="built_in">up</span>(fillCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">procedure <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">down</span>(fillCount);</span><br><span class="line">        <span class="built_in">down</span>(mutex);</span><br><span class="line">        item = <span class="built_in">removeItemFromBuffer</span>();</span><br><span class="line">        <span class="built_in">up</span>(mutex);</span><br><span class="line">        <span class="built_in">up</span>(emptyCount);</span><br><span class="line">        <span class="built_in">consumeItem</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意代码中 while 语句的用法，都是用在测试缓冲区是否已满或空的时候。当存在多个消费者时，有可能造成竞争条件的情况是：某一消费者在一项数据被放入缓冲区中时被唤醒，但是另一消费者已经在管程上等待了一段时间并移除了这项数据。如果 while 语句被改成 if，则会出现放入缓冲区的数据项过多，或移除空缓冲区中的元素的情况。</p><h3 id="2-信号量临界区保护">2.信号量临界区保护</h3><p>多个生产者共同修改emptyCount，由于时间分片执行的关系，有可能使得emptyCount的值与真实情况不符合。这种错误是有多个进程并发操作共享数据引起，与调度顺序有关，难以发现和调试。</p><p>若这种情况(伪代码)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">emptyCount = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//reg是寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者P1进行生产</span></span><br><span class="line">reg = emptyCount;</span><br><span class="line">reg = reg <span class="number">-1</span>;</span><br><span class="line">emptyCount = reg;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者P2进行生产</span></span><br><span class="line">reg = emptyCount;</span><br><span class="line">reg = reg <span class="number">-1</span>;</span><br><span class="line">emptyCount = reg;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际有可能的调度情况</span></span><br><span class="line">p1.reg = emptyCount; <span class="comment">//5</span></span><br><span class="line">p1.reg = p1.reg <span class="number">-1</span>;  <span class="comment">//4</span></span><br><span class="line">p2.reg = emptyCount; <span class="comment">//5</span></span><br><span class="line">p2.reg = p2.reg <span class="number">-1</span>;  <span class="comment">//4</span></span><br><span class="line">emptyCount = p1.reg; <span class="comment">//4</span></span><br><span class="line">emptyCount = p2.reg; <span class="comment">//4</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生产者 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
