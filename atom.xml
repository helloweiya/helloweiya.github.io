<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HelloWei</title>
  
  
  <link href="https://blog.hellowei.ga/atom.xml" rel="self"/>
  
  <link href="https://blog.hellowei.ga/"/>
  <updated>2022-08-16T13:34:42.496Z</updated>
  <id>https://blog.hellowei.ga/</id>
  
  <author>
    <name>不吃西柚</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux统计文件或文件夹数量</title>
    <link href="https://blog.hellowei.ga/2022/08/16/Linux%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9%E6%95%B0%E9%87%8F/"/>
    <id>https://blog.hellowei.ga/2022/08/16/Linux%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9%E6%95%B0%E9%87%8F/</id>
    <published>2022-08-16T13:34:42.496Z</published>
    <updated>2022-08-16T13:34:42.496Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容摘自<a href="http://noahsnail.com/2017/02/07/2017-02-07-Linux%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E7%9B%AE/">Tyan</a>,方便后续自己查询使用，感谢作者</p><h3 id="统计命令">统计命令</h3><p>Linux下有三个命令:<code>ls</code>,<code>grep</code>,<code>wc</code>。通过这三个命令的组合可实现统计目录下文件及文件夹的个数。</p><ol><li><p>统计当前目录下文件个数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l | grep &quot;^-&quot; | wc -l</span><br></pre></td></tr></table></figure></li><li><p>统计当前目录下文件的个数（包括子目录）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lR| grep &quot;^-&quot; | wc -l</span><br></pre></td></tr></table></figure></li><li><p>查看某目录下文件夹(目录)的个数（包括子目录）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lR | grep &quot;^d&quot; | wc -l</span><br></pre></td></tr></table></figure></li></ol><h3 id="命令详解">命令详解</h3><ul><li><p><code>ls -l</code></p><p>长列表输出该目录下文件信息(注意这里的文件是指目录、链接、设备文件等)，每一行对应一个文件或目录，<code>ls -lR</code>是列出所有文件，包括子目录。</p></li><li><p><code>grep &quot;^-&quot;</code></p><p>过滤<code>ls</code>的输出信息。正则表达式&quot;^-&quot;表示以<code>-</code>开头，因为统计文件夹改为<code>^d</code></p></li><li><p><code>wc -l</code></p><p>统计输出信息的行数，统计结果就是输出信息的行数，一行信息对应一个文件</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下内容摘自&lt;a href=&quot;http://noahsnail.com/2017/02/07/2017-02-07-Linux%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%96%87%E</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.hellowei.ga/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ priority_queue使用方法</title>
    <link href="https://blog.hellowei.ga/2022/02/26/priority-queue%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://blog.hellowei.ga/2022/02/26/priority-queue%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2022-02-26T10:58:37.000Z</published>
    <updated>2022-08-16T13:34:42.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优先队列priority-queue">优先队列priority_queue</h2><p>priority_queue是C++提供的优先队列，定义在头文件<code>&lt;queue&gt;</code>中，默认为最大优先队列<br>定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="keyword">class</span> <span class="title">Container</span> =</span> std::vector&lt;T&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Compare</span> =</span> std::less&lt;<span class="keyword">typename</span> Container::value_type&gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">priority_queue</span>;</span></span><br></pre></td></tr></table></figure><h3 id="模板形参">模板形参</h3><ul><li><p>T 存储元素类型</p></li><li><p>Container 用于存储元素的底层容器 如<code>std::vector&lt;T&gt;</code>,<code>std::vector&lt;std::vector&lt;T&gt; &gt;</code>,也就是容器的类型，</p></li><li><p>Compare 严格弱序的<a href="https://zh.cppreference.com/w/cpp/named_req/Compare"><em>比较</em> <em>(Compare)</em> </a>类型</p><p>对于自定义的compare函数，需提供严格弱序。对于比较函数，若返回true,说明left “小于” right<br>比较时，若要左操作数先于右操作数弹出，则应该返回false。(因为priority_queue总是返回**“最大”**的)，若要右操作数先弹出，则应该返回true</p></li></ul><h3 id="常用成员函数">常用成员函数</h3><table><thead><tr><th>成员函数</th><th>作用</th></tr></thead><tbody><tr><td>top</td><td>访问栈顶元素</td></tr><tr><td>empty</td><td>检查队列是否为空</td></tr><tr><td>size</td><td>返回容纳的元素数</td></tr><tr><td>push</td><td>插入元素，并对底层容器排序(自动完成)</td></tr><tr><td>pop</td><td>弹出队列第一个元素</td></tr><tr><td>emplace</td><td>原位构造元素并排序底层容器</td></tr><tr><td>swap</td><td>交换内容</td></tr></tbody></table><h3 id="使用">使用</h3><p>如不特殊</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">print_queue</span><span class="params">(T&amp; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; q.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单使用(大顶堆)</span></span><br><span class="line"><span class="comment">//这里默认使用了std::less&lt;T&gt;，这是一个仿函数类，重载了()操作符</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">constexpr bool operator()(const T &amp;lhs, const T &amp;rhs) const </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return lhs &lt; rhs; </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">std::priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>&#125;)&#123;</span><br><span class="line">q.<span class="built_in">push</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print_queue</span>(q);</span><br><span class="line"><span class="comment">//输出 9 8 7 6 5 4 3 2 1 0 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//小顶堆</span></span><br><span class="line">std::priority_queue&lt;<span class="keyword">int</span>, std::vector&lt;<span class="keyword">int</span>&gt;, std::greater&lt;<span class="keyword">int</span>&gt; &gt; q2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>&#125;)</span><br><span class="line">        q2.<span class="built_in">push</span>(n);</span><br><span class="line"><span class="built_in">print_queue</span>(q2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 0 1 2 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure><p>自定义比较函数</p><p>这里使用<code>std::vector&lt;std::vector&lt;int&gt;&gt;</code>作为底层容器，按二元组std::vector<int>第一个坐标从小到大排序，若相同则第二个坐标从小到大排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">print_queue</span><span class="params">(T&amp; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> temp = q.<span class="built_in">top</span>();</span><br><span class="line">        std::cout &lt;&lt; temp[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;temp[<span class="number">1</span>]&lt;&lt;std::endl;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义比较函数</span></span><br><span class="line"><span class="comment">//对于比较函数，若返回true,说明left是“小于” right的，</span></span><br><span class="line"><span class="comment">//priority_queue总是返回“最大”的，right就会优先被弹出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](std::vector&lt;<span class="keyword">int</span>&gt; left, std::vector&lt;<span class="keyword">int</span>&gt; right) &#123; </span><br><span class="line">        <span class="keyword">if</span>(left[<span class="number">0</span>] == right[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> left[<span class="number">0</span>] &gt; right[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> left[<span class="number">0</span>] &gt; right[<span class="number">0</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    std::priority_queue&lt;std::vector&lt;<span class="keyword">int</span>&gt;, std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q3</span>(cmp);</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; arr&#123;&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">5</span>,<span class="number">7</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;,&#123;<span class="number">9</span>,<span class="number">4</span>&#125;,&#123;<span class="number">4</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n :arr)&#123;</span><br><span class="line">        q3.<span class="built_in">push</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print_queue</span>(q3);;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 5</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">4 2</span></span><br><span class="line"><span class="comment">5 7</span></span><br><span class="line"><span class="comment">9 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;优先队列priority-queue&quot;&gt;优先队列priority_queue&lt;/h2&gt;
&lt;p&gt;priority_queue是C++提供的优先队列，定义在头文件&lt;code&gt;&amp;lt;queue&amp;gt;&lt;/code&gt;中，默认为最大优先队列&lt;br&gt;
定义如下&lt;/p&gt;
&lt;f</summary>
      
    
    
    
    
    <category term="C++" scheme="https://blog.hellowei.ga/tags/C/"/>
    
    <category term="priority_queue" scheme="https://blog.hellowei.ga/tags/priority-queue/"/>
    
  </entry>
  
  <entry>
    <title>C++11随机数</title>
    <link href="https://blog.hellowei.ga/2022/02/25/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <id>https://blog.hellowei.ga/2022/02/25/%E9%9A%8F%E6%9C%BA%E6%95%B0/</id>
    <published>2022-02-25T11:51:13.000Z</published>
    <updated>2022-08-16T13:34:42.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-11-伪随机数生成">c++11 伪随机数生成</h2><p>c++11 随机数库<code>&lt;random&gt;</code>提供生成随机数和伪随机数的类，<br>为生成伪随机数，主要包括两类</p><ol><li>均匀随机位生成器(URBG)，包含随机数引擎，它们是伪随机数生成器，是能够生成均匀分布整数序列的伪随机数</li><li>随机数分布(例如均匀分布，正态分布和泊松分布等)，它们将 URBG 的输出转换为各种统计分布<br>均匀随机位生成器和随机数分布相互使用。所有随机数引擎都可以指定地播种、序列化和反序列化，以用于可重复的模拟器</li></ol><h3 id="均匀随机位生成器">均匀随机位生成器</h3><p>均匀随机位生成器是<strong>函数对象(仿函数类)</strong>，它返回无符号整数值，并使得每个值在可能结果的范围中拥有（理想上）相等的被返回概率<br>主要有以下4种,</p><ol><li>随机数引擎<br>随机数引擎本质是一种算数算法，因此相同的种子多次调用产生的随机数是完全相同的<br>标准提供三种常用的引擎：linear_congruential_engine，mersenne_twister_engine 和 subtract_with_carry_engine。第一种是线性同余算法，第二种是梅森旋转算法，第三种带进位的线性同余算法。</li><li>随机数引擎适配器<br>随机数引擎适配器生成以另一随机数引擎为熵源的伪随机数</li><li>预定义随机数生成器<br>具体见<a href="!https://zh.cppreference.com/w/cpp/numeric/random">伪随机数生成</a><br>常用的有default_random_engine，mt19937，minstd_rand0等</li><li>非确定随机数生成器<br>使用硬件熵源的非确定随机数生成器<br>std::random_device</li></ol><p>使用方法<br>正常使用我们只需要使用预定义随机数生成器或者非确定随机数即可<br>随机数引擎接受一个整形参数当作种子，不提供的话，会使用默认值。如果想多次运行产生相同的随机数，可以使用一个确定的数作为种子。如果是想每次运行生成不一样的随机数，Linux 推荐使用 random_device 来产生一个随机数当作种子，windows 产生一个伪随机数作为种子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//选择某一种随机数生成器或者</span></span><br><span class="line">    std::random_device rd;  <span class="comment">//使用硬件熵源</span></span><br><span class="line">    <span class="comment">//将rd生成的非确定随机数作为随机数引擎的种子，当然自定义也行，相同的种子多次调用产生的随机数是完全相同</span></span><br><span class="line">    <span class="function">std::default_random_engine <span class="title">e</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="comment">//生成10个随机数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="built_in">e</span>()&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机数分布">随机数分布</h3><p>随机数分布后处理 URBG 的输出，以使得输出结果按照定义的统计概率密度函数分布<br>具体间<a href="https://zh.cppreference.com/w/cpp/numeric/random">随机数分布</a>中提供的类，常见的有均匀，正态等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 以随机值播种，若可能</span></span><br><span class="line">    std::random_device r;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 选择 1 与 6 间的随机数</span></span><br><span class="line">    <span class="function">std::default_random_engine <span class="title">e1</span><span class="params">(r())</span></span>;</span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; <span class="title">uniform_dist</span><span class="params">(<span class="number">1</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> mean = <span class="built_in">uniform_dist</span>(e1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Randomly-chosen mean: &quot;</span> &lt;&lt; mean &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值最可能接近平均</span></span><br><span class="line">    <span class="comment">// 标准差影响生成的值距离平均数的分散</span></span><br><span class="line">    std::random_device rd;</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">    std::normal_distribution&lt;&gt; d&#123;<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    std::map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hist&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;<span class="number">10000</span>; ++n) &#123;</span><br><span class="line">        ++hist[std::<span class="built_in">round</span>(<span class="built_in">d</span>(gen))];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : hist) &#123;</span><br><span class="line">        std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>)</span><br><span class="line">                  &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::<span class="built_in">string</span>(p.second/<span class="number">200</span>, <span class="string">&#x27;*&#x27;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-11-伪随机数生成&quot;&gt;c++11 伪随机数生成&lt;/h2&gt;
&lt;p&gt;c++11 随机数库&lt;code&gt;&amp;lt;random&amp;gt;&lt;/code&gt;提供生成随机数和伪随机数的类，&lt;br&gt;
为生成伪随机数，主要包括两类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;均匀随机位生成器(URBG</summary>
      
    
    
    
    <category term="C++" scheme="https://blog.hellowei.ga/categories/C/"/>
    
    
    <category term="C++" scheme="https://blog.hellowei.ga/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>c++分割字符串</title>
    <link href="https://blog.hellowei.ga/2021/12/27/c-%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://blog.hellowei.ga/2021/12/27/c-%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-12-27T03:05:43.000Z</published>
    <updated>2022-08-16T13:34:42.497Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用stringstream-getline">使用stringstream + getline</h3><p>使用<a href="https://www.cplusplus.com/reference/string/string/getline/">getline</a>进行分割<br>局限性，只能以单个字符作为分割线</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">istringstream <span class="title">ss</span><span class="params">(<span class="string">&quot;helloahelloahello&quot;</span>)</span></span>;</span><br><span class="line">    string word;</span><br><span class="line">    <span class="keyword">char</span> delim = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(ss,word,delim))&#123;</span><br><span class="line">        cout&lt;&lt;word&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="使用std-string-find">使用std::string::find</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for string delimiter</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span> <span class="params">(<span class="keyword">const</span> string&amp; s, <span class="keyword">const</span> string&amp; delimiter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> pos_start = <span class="number">0</span>, pos_end, delim_len = delimiter.<span class="built_in">length</span>();</span><br><span class="line">    string token;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pos_end = s.<span class="built_in">find</span> (delimiter, pos_start)) != string::npos) &#123;</span><br><span class="line">        token = s.<span class="built_in">substr</span> (pos_start, pos_end - pos_start);</span><br><span class="line">        pos_start = pos_end + delim_len;</span><br><span class="line">        <span class="keyword">if</span>(!token.<span class="built_in">empty</span>())</span><br><span class="line">        res.<span class="built_in">push_back</span> (token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos_start != s.<span class="built_in">size</span>())</span><br><span class="line">        res.<span class="built_in">push_back</span> (s.<span class="built_in">substr</span> (pos_start));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;adsf-+qwret-+nvfkbdsj-+orthdfjgh-+dfjrleih&quot;</span>;</span><br><span class="line">    string delimiter = <span class="string">&quot;-+&quot;</span>;</span><br><span class="line">    vector&lt;string&gt; v = <span class="built_in">split</span> (str, delimiter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : v) cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">adsf</span></span><br><span class="line"><span class="comment">qwret</span></span><br><span class="line"><span class="comment">nvfkbdsj</span></span><br><span class="line"><span class="comment">orthdfjgh</span></span><br><span class="line"><span class="comment">dfjrleih</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;使用stringstream-getline&quot;&gt;使用stringstream + getline&lt;/h3&gt;
&lt;p&gt;使用&lt;a href=&quot;https://www.cplusplus.com/reference/string/string/getline/&quot;&gt;getl</summary>
      
    
    
    
    <category term="C++" scheme="https://blog.hellowei.ga/categories/C/"/>
    
    
    <category term="C++" scheme="https://blog.hellowei.ga/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="https://blog.hellowei.ga/2021/12/23/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.hellowei.ga/2021/12/23/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-23T06:51:02.000Z</published>
    <updated>2022-08-16T13:34:42.497Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/tianyicui/pack">背包九讲</a></p></blockquote><h2 id="0-1背包">0-1背包</h2><h3 id="题目">题目</h3><p>有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>件物品和最多承载量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span>的背包。第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>件物品的重量是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其价值是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><h3 id="基本思路">基本思路</h3><p>作为最基础的背包问题，其特点是<strong>每件物品最多用一次</strong><br>用子问题定义状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F[i,w]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span></span></span></span>表示前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>件物品放入承载量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>的背包可获得的最大价值，则状态转移方程便是</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>w</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo>+</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F[i,w] = max(F[i-1,w],F[i-1,w-w_i]+v_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>其代表的意思是若只考虑第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>件物品的策略（放或不放），那么就可以转化为一个只和前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>件物品相关的问题。</p><ul><li>如果不放第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>件物品，问题就转化为“前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>件物品放入容量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>的背包中”，价值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F[i-1,w]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span></span></span></span>；</li><li>如果放第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>件物品，问题就转化为“前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>件物品放入剩下的容量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w-w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的背包中”，此时能获得的最大价值就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>w</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F[i-1,w-w_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>再加上通过放入第i件物品获得的价值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li></ul><h3 id="代码实现">代码实现</h3><p>先遍历物品再遍历容量(横向更新)<br><img src="/img/algorithm/01pack_2d.png" alt="二维实现"></p><p>先遍历容量再遍历物品(纵向更新)<br><img src="/img/algorithm/01pack_2d_packfirst.png" alt="二维实现"><br>蓝色方块表示更新完成，绿色表示当前需要更新的值，红色表示还未更新，带文字的方块表示更新当前值所需要的值。<br>可以看出，对于二维实现，先遍历背包容量或者先遍历物品都可以，因为更新当前位置所需信息时所需要的值(蓝色带文字方块)都已经更新完成</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>a</mi><mi>g</mi><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">bagWeight</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ba</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span>为背包重量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">weight</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span>表示重量数组，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span>表示价值数组，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先遍历物品再遍历容量(横向更新)      </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zeroOnePack</span><span class="params">(<span class="keyword">int</span> bagWeight,vector&lt;<span class="keyword">int</span>&gt; weight,vector&lt;<span class="keyword">int</span>&gt; value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = weight.<span class="built_in">size</span>(), n = bagWeight;</span><br><span class="line">    <span class="comment">// dp[i][j] 表示对于前i件物品，容量为j的背包所能获得的最大价值</span></span><br><span class="line">    <span class="comment">//初始化 dp[*][0] = 0 dp[0][*] = 0</span></span><br><span class="line">    <span class="keyword">int</span> dp[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m+<span class="number">1</span>; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n+<span class="number">1</span>; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i]) </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先遍历容量再遍历物品(纵向更新)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) </span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="空间优化">空间优化</h3><p>采用一维数组去替代二维数组，这要求在dp能够同时保存上一层信息和更新本层<br>因为更新当前位置所需信息只在<strong>上一层左边和正上方</strong>，必需采用逆序。<br><img src="/img/algorithm/01pack_1d.png" alt="一维实现"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zeroOnePack</span><span class="params">(<span class="keyword">int</span> bagWeight,vector&lt;<span class="keyword">int</span>&gt; weight,vector&lt;<span class="keyword">int</span>&gt; value)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="comment">//这样保证物体i只在本次循环被使用，因为等式右边的dp保存的是前i-1个物品</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[bagWeight];   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包">完全背包</h2><p>完全背包与0-1背包的区别在于物品的个数是无限的，即可重复选择相同物品填充</p><h3 id="基本思路-2">基本思路</h3><ol><li>基本思路<br>模仿0-1背包的解法</li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>w</mi><mo>−</mo><mi>k</mi><mo>∗</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo>+</mo><mi>k</mi><mo>∗</mo><msub><mi>v</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>k</mi><mo>∗</mo><msub><mi>w</mi><mi>i</mi></msub><mo>&lt;</mo><mo>=</mo><mi>W</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F[i,w] = max\{F[i-1,w-k*w_i]+k*v_i | 0&lt;=k*w_i&lt;=W\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mclose">}</span></span></span></span></span></p><ol start="2"><li>转换为0-1背包<br>每个物品i,最多能放<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>W</mi><msub><mi>w</mi><mi>i</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{W}{w_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3174em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0269em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>件，那么就把第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>件扩充至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>W</mi><msub><mi>w</mi><mi>i</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{W}{w_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3174em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0269em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>件，然后解决这个0-1背包问题<br>则状态转移方程便是<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>w</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo>+</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F[i,w] = max(F[i-1,w],F[i,w-w_i]+v_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p></li></ol><ul><li>如果不放第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>件物品，问题就转化为“前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>件物品放入容量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>的背包中”，价值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F[i-1,w]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span></span></span></span>；</li><li>在考虑“选一件第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>种物品”时，需要一个可能已选入第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>种物品的子结果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>w</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F[i,w-w_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>。而不是只选到前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的子结果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>w</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F[i-1,w-w_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li></ul><h3 id="二维实现">二维实现</h3><p>先遍历物品再遍历容量(横向更新)<br><img src="/img/algorithm/completepack_2d.png" alt="二维实现"><br>先遍历容量再遍历物品(纵向更新)<br><img src="/img/algorithm/completepack_2d_packfirst.png" alt="二维实现"></p><p>和0-1背包一样，对于二维实现，先遍历物品和先遍历容量都是可行的。原因就在于不管采用那种遍历顺利总是保证更新当前位置时所需要的信息已经准备好了</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>a</mi><mi>g</mi><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">bagWeight</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ba</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span>为背包重量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">weight</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span>表示重量数组，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span>表示价值数组，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">completePack</span><span class="params">(<span class="keyword">int</span> bagWeight,vector&lt;<span class="keyword">int</span>&gt; weight,vector&lt;<span class="keyword">int</span>&gt; value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = weight.<span class="built_in">size</span>(), n = bagWeight;</span><br><span class="line">    <span class="comment">// dp[i][j] 表示对于前i件物品，容量为j的背包所能获得的最大价值</span></span><br><span class="line">    <span class="comment">//初始化 dp[*][0] = 0 dp[0][*] = 0</span></span><br><span class="line">    <span class="keyword">int</span> dp[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m+<span class="number">1</span>; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n+<span class="number">1</span>; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i]) </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空间优化-2">空间优化</h3><p>采用一维数组去替代二维数组，<br>因为更新当前位置所需信息<strong>本层左边和正上方</strong>，对应到一维就是当前位置左边和自身位置，需采用正向遍历，及时更新本层左边方块<br><img src="/img/algorithm/completepack_1d.png" alt="一维实现"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">completePack</span><span class="params">(<span class="keyword">int</span> bagWeight,vector&lt;<span class="keyword">int</span>&gt; weight,vector&lt;<span class="keyword">int</span>&gt; value)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品       </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = weight[i]; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[bagWeight];   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>不管是0-1背包还是完全背包，其二维实现两种遍历顺序都是可以的</li><li>0-1背包和完全背包解决的是组合问题，并非排列问题，排列问题参考爬楼梯</li><li>0-1背包和完全背包组合问题都是外层遍历物品，内层遍历背包容量。</li><li>0-1背包是<strong>逆向</strong>遍历背包容量，保证当前物品最多一个被加入。完全背包<strong>正向</strong>遍历，使得可以当前物品可多次被加入</li><li>对于排列问题，先遍历背包，在遍历物品。<a href="https://leetcode-cn.com/problems/combination-sum-iv/">参考爬楼梯进阶版</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tianyicui/pack&quot;&gt;背包九讲&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0-1背包&quot;&gt;0-1背包&lt;/h2&gt;
&lt;h3 id=&quot;题目&quot;&gt;题目&lt;/h3&gt;
&lt;p&gt;有&lt;sp</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.hellowei.ga/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="背包问题" scheme="https://blog.hellowei.ga/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>排序算法(三)——堆、计数、桶、基数排序</title>
    <link href="https://blog.hellowei.ga/2021/12/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9503/"/>
    <id>https://blog.hellowei.ga/2021/12/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9503/</id>
    <published>2021-12-09T08:56:11.000Z</published>
    <updated>2022-08-16T13:34:42.497Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆排序">堆排序</h3><p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。</p><h4 id="堆的概念">堆的概念</h4><p>堆是一种完全二叉树，这使得堆(完全二叉树)可以用数组进行表示。如下图每一个节点对应数组的一个元素且可以通过数组下标来判断节点间位置。<br>对于给定下标为<code>i</code>的数组中的数组,其该元素所对应的父节点、孩子节点下标为(以1作为开始)：<br>父节点：    <code>Parent(i) = floor(i/2)</code><br>左孩子节点： <code>Left(i) = 2*i</code><br>右孩子节点:  <code>Right(i)= 2*i +1</code><br><img src="/img/algorithm/heap.png" alt="heap"></p><ul><li>最大堆即最大元素值出现在根结点，堆中每个父节点的元素值都大于等于其孩子结点 用于<strong>升序</strong>排列</li><li>最小堆中的最小元素值出现在根结点，堆中每个父节点的元素值都小于等于其孩子结点 用于<strong>降序</strong>排列</li></ul><h4 id="算法描述">算法描述</h4><p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作</p><ul><li><p>最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</p></li><li><p>创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆<br><img src="/img/algorithm/buildHeap.gif" alt="buildHeap"></p></li><li><p>移除位在第一个数据的根节点，并做最大堆调整的递归运算<br><img src="/img/algorithm/adjustHeap.gif" alt="adjustHeap"></p></li></ul><h4 id="算法实现">算法实现</h4><p>需要注意的一个问题是：数组都是 Zero-Based，这就意味着我们的堆数据结构模型要发生改变即<br>对于给定下标为<code>i</code>的数组中的数组,其该元素所对应的父节点、孩子节点下标为(以0作为开始)：<br>父节点：    <code>Parent(i) = floor((i-1)/2)</code><br>左孩子节点： <code>Left(i) = 2*i+1</code><br>右孩子节点:  <code>Right(i)= 2*(i+1)</code></p><p>对于利用堆排序，只关心两个问题</p><ol><li>给定一个无序数组，如何建立堆</li><li>删除堆顶元素，如何调整成为新的堆</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = len<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//初始化最大堆</span></span><br><span class="line">    <span class="comment">//从第一个非叶子节点开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">getParentIndex</span>(lastIndex); i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="built_in">adjustHeap</span>(arr,i,lastIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除堆顶元素,重新调整堆</span></span><br><span class="line">    <span class="keyword">while</span>(lastIndex&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>],arr[lastIndex]);</span><br><span class="line">        lastIndex--;</span><br><span class="line">        <span class="built_in">adjustHeap</span>(arr,<span class="number">0</span>,lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> curIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left,right,exchangeIndex;</span><br><span class="line">    left = <span class="built_in">getLeftChildIndex</span>(curIndex);</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= endIndex)&#123;</span><br><span class="line">        <span class="comment">//选择左右孩子中较大的进行交换</span></span><br><span class="line">        right = left  + <span class="number">1</span>;</span><br><span class="line">        exchangeIndex = left;</span><br><span class="line">        <span class="keyword">if</span>(right &lt;= endIndex &amp;&amp; arr[left] &lt; arr[right])&#123;</span><br><span class="line">            exchangeIndex = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若当前节点小于其孩子节点，交换并下沉</span></span><br><span class="line">        <span class="keyword">if</span>(arr[curIndex] &lt; arr[exchangeIndex])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[curIndex],arr[exchangeIndex]);</span><br><span class="line">            curIndex = exchangeIndex;</span><br><span class="line">            left = <span class="built_in">getLeftChildIndex</span>(curIndex);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParentIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (index<span class="number">-1</span>) /<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLeftChildIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法特点">算法特点</h4><ol><li>堆排序存在大量的筛选和移动过程，属于不稳定的排序算法</li><li>堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用</li><li>在元素比较多的情况下,尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。</li></ol><h3 id="计数排序">计数排序</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是<strong>有确定范围的整数</strong>。</p><h4 id="算法描述-2">算法描述</h4><ol><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li></ol><h4 id="动图演示">动图演示</h4><p><img src="/img/algorithm/countSort.gif" alt="countSort"></p><h4 id="算法实现-2">算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len, <span class="keyword">int</span> maxVal, <span class="keyword">int</span> minVal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cntLen = maxVal- minVal + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>* cntVec = <span class="keyword">new</span> <span class="keyword">int</span>[cntLen];</span><br><span class="line">    <span class="comment">//初始化为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = minVal; i &lt;= maxVal;i++)</span><br><span class="line">        cntVec[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计每个值出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++ )&#123;</span><br><span class="line">        cntVec[arr[i]-minVal]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照计数顺序将其依次填充到原数组中</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;  <span class="comment">//指向计数数组</span></span><br><span class="line">    <span class="keyword">int</span> curIndex = <span class="number">0</span>; <span class="comment">//指向需要被填充的数组</span></span><br><span class="line">    <span class="keyword">while</span>(p &lt; cntLen)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cntVec[p] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            arr[curIndex++] = p + minVal;</span><br><span class="line">            cntVec[p]--;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []cntVec;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法特点-2">算法特点</h4><ol><li>排序目标要能够映射到整数域，其最大值最小值应当容易辨别</li><li>计数排序需要占用大量空间，它比较适用于数据比较集中的情况</li></ol><h3 id="桶排序">桶排序</h3><p>桶排序又叫箱排序，是计数排序的升级版，它的工作原理是将数组分到有限数量的桶子里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。</p><blockquote><p>计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况<br>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p></blockquote><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><h4 id="算法描述-3">算法描述</h4><ol><li>找出待排序数组中的最大值max、最小值min</li><li>使用数组作为桶，桶里放的元素用存储。桶的数量为(max-min)/arr.length+1</li><li>遍历数组 arr，计算每个元素 arr[i] 放的桶</li><li>每个桶各自排序</li><li>遍历桶数组，把排序好的元素放进输出数组</li></ol><h4 id="图片解释">图片解释</h4><p><img src="/img/algorithm/bucketSort.png" alt="bucketSort"></p><h4 id="算法特点-3">算法特点</h4><ol><li>当输入数据可以均匀的分配到桶最快</li><li>空间复杂度：O(n+k)，时间复杂度O(n+k)</li></ol><h3 id="基数排序">基数排序</h3><p>基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。<br>排序过程：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p><p>实际上，基数排序算法对排序元素的类型不要求一定是非负整数才可以进行，其对于字符串、浮点数等类型均可适用。其关键在于要求排序元素的数位长度统一。例如对整数排序时，如果排序元素中含有负数，则可以对排序元素均加上一个数使其全部为非负整数；如果元素类型是字符串的话，在计数排序过程中，可以直接使用该位字符对应ASCII码值进行计数，对于长度不足的字符串，可直接在其后面补0实现长度对齐。即在计数排序过程中，如果发现某位字符是为对齐所填充的0的话，则可认为其对应的ASCII码值为0进行计数，因为字符’A’所对应的ASCII码值是65，字符’0’所对应的ASCII码值是48，均比0大。这样即可保证基数排序的结果是符合字典序的实现</p><h4 id="动图演示-2">动图演示</h4><p><img src="/img/algorithm/radixSort.gif" alt="radixSort"></p><h4 id="算法特点-4">算法特点</h4><ol><li><p>通过上面的排序过程，我们可以看到，每一轮映射和收集操作，都保持从左到右的顺序进行，如果出现相同的元素，则保持他们在原始数组中的顺序。可见，基数排序是一种稳定的排序。</p></li><li><p>基数排序要求较高，元素必须是整数，整数时长度10W以上，最大值100W以下效率较好，但是基数排序比其他排序好在可以适用字符串，或者其他需要根据多个条件进行排序的场景，例如日期，先排序日，再排序月，最后排序年 ，其它排序算法可是做不了的</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;堆排序&quot;&gt;堆排序&lt;/h3&gt;
&lt;p&gt;堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.hellowei.ga/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="https://blog.hellowei.ga/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法(二)——希尔、快速、归并</title>
    <link href="https://blog.hellowei.ga/2021/12/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9502/"/>
    <id>https://blog.hellowei.ga/2021/12/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9502/</id>
    <published>2021-12-07T14:26:47.000Z</published>
    <updated>2022-08-16T13:34:42.497Z</updated>
    
    <content type="html"><![CDATA[<h3 id="希尔排序-插入排序的改良版">希尔排序(插入排序的改良版)</h3><p>在希尔排序出现之前，计算机界普遍存在“排序算法不可能突破O(n2)”的观点。希尔排序是第一个突破O(n2)的排序算法，它是简单插入排序的改进版。希尔排序的提出，主要基于以下两点：</p><ol><li>插入排序算法在数组基本有序的情况下，可以近似达到O(n)复杂度，效率极高。</li><li>但插入排序每次只能将数据移动一位，在数组较大且基本无序的情况下性能会迅速恶化。</li></ol><h4 id="算法描述">算法描述</h4><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录&quot;基本有序&quot;时，再对全体记录进行依次直接插入排序</p><ol><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行 k 趟排序</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度<br><img src="/img/algorithm/shellSortDes.png" alt="希尔排序"></li></ol><h4 id="动图演示">动图演示</h4><p><img src="/img/algorithm/shellSort.gif" alt="希尔排序"></p><h4 id="算法实现">算法实现</h4><p>在希尔排序的理解时，我们倾向于对于每一个分组，逐组进行处理，但在代码实现中，我们可以不用这么按部就班地处理完一组再调转回来处理下一组,实现时不用循环按组处理，我们可以从第gap个元素开始，逐个跨组处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Donald Shell增量 每次分组减半</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">//增量delta，并逐步缩小增量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> delta = len / <span class="number">2</span>; delta &gt;<span class="number">0</span>; delta /= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//从第delta个元素开始，逐个对其所在组进行直接插入排序操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = delta; i&lt;len;i++)&#123;</span><br><span class="line">            <span class="comment">//寻找可以插入的位置</span></span><br><span class="line">            <span class="keyword">int</span> pos = i;</span><br><span class="line">            <span class="keyword">int</span> curVal = arr[i];</span><br><span class="line">            <span class="keyword">while</span>(pos &gt;= delta &amp;&amp; arr[pos-delta] &gt; curVal)&#123;</span><br><span class="line">                arr[pos] = arr[pos-delta];</span><br><span class="line">                pos-=delta;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[pos] = curVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法特点">算法特点</h4><ol><li>希尔排序的增量数列可以任取，需要的唯一条件是最后一个一定为1（因为要保证按1有序）</li><li>Donald Shell提出的增量，即折半降低直到1,其时间复杂度还是O(n2)。Hibbard经过复杂证明可使得最坏时间复杂度为O(n3/2)</li><li>Shell排序不是一个稳定的算法</li></ol><h3 id="快速排序">快速排序</h3><p>快速排序算法知名度较高，对于大数据具有优秀的排序性能和相对简单的算法实现。快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><h4 id="算法描述-2">算法描述</h4><ol><li>从序列中挑出一个元素作为基准(pivot)</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区(partition)操作。</li><li>递归的把左右两边的字序列进行排序</li><li>直到子数组长度为1</li></ol><h4 id="动图演示-2">动图演示</h4><p><img src="/img/algorithm/quickSort.gif" alt="快速排序"></p><h4 id="算法实现-2">算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//left 数组起始下标</span></span><br><span class="line">    <span class="comment">//right 数组结束下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归终止条件 数组长度为1</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//执行partition操作，将数组分为两个子数组</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = <span class="built_in">partition</span>(arr,left,right);</span><br><span class="line">    <span class="comment">//递归调用</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr,left,pivotIndex<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr,pivotIndex,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//选定第一个元素作为基准(可随意)</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="comment">//所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;right)&#123;</span><br><span class="line">        <span class="comment">//采取双指针的方式,移动left和right</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;right &amp;&amp; arr[right] &gt;=pivot)</span><br><span class="line">            --right;</span><br><span class="line">        arr[left] = arr[right]; <span class="comment">//交换比基准值小的至左边</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;right &amp;&amp; arr[left] &lt;=pivot)</span><br><span class="line">            ++left;</span><br><span class="line">        arr[right] = arr[left]; <span class="comment">//交换比基准值大的至右边</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//扫描完成，基准到位</span></span><br><span class="line">        arr[left] = pivot;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//划分第二方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//随机选中一个元素作为基准arr[p],并放置末尾</span></span><br><span class="line">    <span class="comment">//swap(arr[p],arr[right]);</span></span><br><span class="line">    <span class="comment">//这里直接选择arr[right]作为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[right];</span><br><span class="line">    <span class="comment">//双指针</span></span><br><span class="line">    <span class="comment">//[left,i）均小于等于pivot</span></span><br><span class="line">    <span class="comment">//[i,j)均大于等于pivot</span></span><br><span class="line">    <span class="comment">//[j,right）表示未扫描区间</span></span><br><span class="line">    <span class="keyword">int</span> i = left; </span><br><span class="line">    <span class="comment">//扫描除基准外的元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = left;j &lt; right;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &lt;= pivot)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将基准放置正确位置</span></span><br><span class="line">    <span class="built_in">swap</span>(arr[i],arr[right]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/algorithm/partition.png" alt="partition"></p><h4 id="算法特点-2">算法特点</h4><ol><li>快速排序并不是稳定的。这是因为我们无法保证相等的数据按顺序被扫描到和按顺序存放</li><li>在最坏状况下时间复杂度(顺序数列)则需要 Ο(n2),平均Ο(nlogn)</li></ol><h3 id="归并排序">归并排序</h3><h4 id="算法描述-3">算法描述</h4><p><img src="/img/algorithm/mergeSort.png" alt="mergeSort"></p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一指针到达序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol><h4 id="动图演示-3">动图演示</h4><p><img src="/img/algorithm/mergeSort.gif" alt="mergeSort"></p><h4 id="算法实现-3">算法实现</h4><h5 id="数组排序">数组排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left) /<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//左数组 [left,mid] 右子数组[mid+1,right]</span></span><br><span class="line">    <span class="built_in">mergeSort</span>(arr,left,mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr,mid+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="built_in">merge</span>(arr,left,mid,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并两个有序数组</span></span><br><span class="line"><span class="comment">//左数组 [left,mid] 右子数组[mid+1,right]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//申请空间</span></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//合并两个子数组</span></span><br><span class="line">    <span class="keyword">int</span> i = left,j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">        p[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;=mid)&#123;</span><br><span class="line">        p[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( j&lt;=right)&#123;</span><br><span class="line">        p[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把数据复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = left;i&lt;=right;i++)&#123;</span><br><span class="line">        arr[i] = p[i-left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="链表归并排序">链表归并排序</h5><p><img src="/img/algorithm/ListMergeSort.png" alt="ListMergeSort"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的归并排序</span></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mergeSort</span>(head,<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从头到尾进行排序，返回排序好的头指针</span></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeSort</span><span class="params">(ListNode* head,ListNode* tail)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只剩最后一个节点,tail不进行排序</span></span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next == tail)&#123;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快慢指针寻找中间</span></span><br><span class="line">    ListNode* slow = head,*fast =head,*mid = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != tail)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast != tail)</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    mid = slow;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">mergeSort</span>(head,mid),<span class="built_in">mergeSort</span>(mid,tail));</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* list1,ListNode* list2)</span></span>&#123;</span><br><span class="line">    ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* pre = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(list1 &amp;&amp; list2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1-&gt;val &lt; list2-&gt;val)&#123;</span><br><span class="line">            pre-&gt;next = list1;</span><br><span class="line">            list1 = list1-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre-&gt;next = list2;</span><br><span class="line">            list2 = list2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(list1)&#123;</span><br><span class="line">        pre-&gt;next = list1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pre-&gt;next = list2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法特点-3">算法特点</h4><ol><li>时间复杂度平均Ο(nlogn),对于数组需要O(n)的空间复杂度，对于链表只需要O(1)</li><li>常用于给链表排序</li><li>因为我们在遇到相等的数据的时候必然是按顺序“抄写”到辅助数组上的，所以，归并排序同样是稳定算法。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;希尔排序-插入排序的改良版&quot;&gt;希尔排序(插入排序的改良版)&lt;/h3&gt;
&lt;p&gt;在希尔排序出现之前，计算机界普遍存在“排序算法不可能突破O(n2)”的观点。希尔排序是第一个突破O(n2)的排序算法，它是简单插入排序的改进版。希尔排序的提出，主要基于以下两点：&lt;/p&gt;
</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.hellowei.ga/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="https://blog.hellowei.ga/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法(一)——冒泡、选择、插入</title>
    <link href="https://blog.hellowei.ga/2021/12/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9501/"/>
    <id>https://blog.hellowei.ga/2021/12/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9501/</id>
    <published>2021-12-07T12:47:09.000Z</published>
    <updated>2022-08-16T13:34:42.497Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法是最基本的算法。排序算法分为<strong>内部排序</strong>和<strong>外部排序</strong>。</p><p>内部排序：数据记录在内存中进行排序，不需要访问外存</p><p>外部排序：因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p><p>常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：</p><p><img src="/img/algorithm/sort.png" alt="排序"></p><p>名词解释:</p><ul><li>n 数据规模</li><li>k 桶的个数</li><li>In-place 占用常数内存，不占用额外内存</li><li>Out-place 占用额外内存</li><li>稳定性 排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li></ul><h3 id="冒泡排序">冒泡排序</h3><p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢&quot;浮&quot;到数列的顶端。</p><h4 id="算法描述">算法描述</h4><ol><li>比较相邻元素，如果第一个比第二个大，则交换他们的位置</li><li>对每一对相邻元素对同样的工作，从开始第一对到结尾的最后一对，</li><li>针对所有元素重复以上的步骤，除了最后一个</li><li>重复步骤1～3,知道所有排序完成</li></ol><h4 id="动图演示">动图演示</h4><p><img src="/img/algorithm/bubbleSort.gif" alt="冒泡排序"></p><h4 id="算法实现">算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;<span class="comment">// 需要排序的长度，共len-1次循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;<span class="comment">//从第1个元素到第i个元素</span></span><br><span class="line">          <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])</span><br><span class="line">              <span class="built_in">swap</span>(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="comment">//end loop j</span></span><br><span class="line">    &#125;<span class="comment">//end loop i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法特点">算法特点</h4><ol><li>在相邻元素相等时，它们并不会交换位置，所以，冒泡排序是稳定排序</li><li>每完成一次第一层循环，会使得当前需要排序的数组<code> arr[0]-arr[i]</code>中最大的数被放置末尾下标为<code>i</code>的位置</li><li>算法复杂度总是O(n^2)，除非有序状态下提前结束，也需要O(n)</li><li>冒泡排序思路简单，代码也简单，特别适合小数据的排序。但是，由于算法复杂度较高，在数据量大的时候不适合使用。</li></ol><h4 id="代码优化">代码优化</h4><p>要使算法在最佳情况下有O(n)复杂度，需要做一些改进，增加一个<code>swap</code>的标志，当前一轮没有进行交换时，说明数组已经有序，没有必要再进行下一轮的循环了，直接退出。(意义不大)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isSwap = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;<span class="comment">// 需要排序的长度，共len-1次循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;<span class="comment">//从第1个元素到第i个元素</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">              <span class="built_in">swap</span>(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">              isSwap = <span class="literal">true</span>;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;<span class="comment">//end loop j</span></span><br><span class="line">      <span class="comment">//没有交换，提前结束</span></span><br><span class="line">      <span class="keyword">if</span>(!isSwap)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="comment">//end loop i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序">选择排序</h3><p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。</p><h4 id="算法描述-2">算法描述</h4><ol><li>在<strong>未排序</strong>序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>从剩余未排序元素中继续寻找最小（大）元素，然后放到<strong>已排序</strong>序列的末尾</li><li>重复第二步，直到所有元素均排序完毕</li></ol><h4 id="动图演示-2">动图演示</h4><p><img src="/img/algorithm/selectionSort.gif" alt="选择排序"></p><h4 id="算法实现-2">算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minIndex;</span><br><span class="line">    <span class="comment">//有序序列 [0,i)</span></span><br><span class="line">    <span class="comment">//无序序列 [i,len)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="comment">//寻找无序序列中中最小的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =i;j&lt;len;j++)</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min])&#123;</span><br><span class="line">              minIndex = j;</span><br><span class="line">            &#125;      </span><br><span class="line">      <span class="comment">//将最小值与无序序列第一个值交换</span></span><br><span class="line">      <span class="built_in">swap</span>(arr[minIndex],arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法特点-2">算法特点</h4><ol><li>选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是优于冒泡排序的</li><li>数组实现的选择排序是不稳定的，用链表实现的选择排序是稳定的</li><li>算法复杂度总是O(n^2)</li></ol><h3 id="插入排序">插入排序</h3><p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p><h4 id="算法描述-3">算法描述</h4><ol><li>把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的</li><li>从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置</li><li>重复上述过程直到最后一个元素被插入有序子数组中</li></ol><h4 id="动图演示-3">动图演示</h4><p><img src="/img/algorithm/insertionSort.gif" alt="插入排序"></p><h4 id="算法实现-3">算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">//有序序列 [0,i）</span></span><br><span class="line">    <span class="comment">//无序序列 [i,len)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">//需要插入的值</span></span><br><span class="line">        <span class="keyword">int</span> curVal = arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找可以插入的位置</span></span><br><span class="line">        <span class="keyword">int</span> pos = i;</span><br><span class="line">        <span class="comment">//逐个比较，若arr[pos-1]大于插入的值则向后移动</span></span><br><span class="line">        <span class="keyword">while</span>(pos &gt;=<span class="number">1</span> &amp;&amp; arr[pos<span class="number">-1</span>]&gt;curVal)&#123;</span><br><span class="line">            arr[pos] = arr[pos<span class="number">-1</span>];</span><br><span class="line">            pos--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[pos] = curVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法特点-3">算法特点</h4><ol><li>由于只需要找到不大于当前数的位置而并不需要交换，因此，直接插入排序是稳定的排序方法</li><li>算法复杂度总是O(n^2),在数据比较少的时候，是一个不错的选择，一般做为快速排序的扩充</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;排序算法是最基本的算法。排序算法分为&lt;strong&gt;内部排序&lt;/strong&gt;和&lt;strong&gt;外部排序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;内部排序：数据记录在内存中进行排序，不需要访问外存&lt;/p&gt;
&lt;p&gt;外部排序：因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.hellowei.ga/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="https://blog.hellowei.ga/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>docker容器cron任务读取环境变量</title>
    <link href="https://blog.hellowei.ga/2021/11/28/docker%E5%AE%B9%E5%99%A8cron%E4%BB%BB%E5%8A%A1%E8%AF%BB%E5%8F%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://blog.hellowei.ga/2021/11/28/docker%E5%AE%B9%E5%99%A8cron%E4%BB%BB%E5%8A%A1%E8%AF%BB%E5%8F%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2021-11-28T03:13:18.000Z</published>
    <updated>2022-08-16T13:34:42.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>​因为<em>cron</em>从非交互式、非登录 shell 运行作业。所以当<a href="https://www.baeldung.com/cron-expressions"><em>cron</em></a>执行作业时，它不会从<a href="https://www.baeldung.com/linux/bashrc-vs-bash-profile-vs-profile"><em>~/.bashrc</em></a><a href="https://www.baeldung.com/linux/bashrc-vs-bash-profile-vs-profile">、</a><a href="https://www.baeldung.com/linux/bashrc-vs-bash-profile-vs-profile"><em>~/.bash_profile</em></a><a href="https://www.baeldung.com/linux/bashrc-vs-bash-profile-vs-profile">、</a><a href="https://www.baeldung.com/linux/bashrc-vs-bash-profile-vs-profile"><em>/etc/profile 等</em></a>文件加载<a href="https://www.baeldung.com/linux/environment-variables">环境变量</a>。当我们需要使用容器内的环境变量作为参数定时运行shell脚本时，由于无法读取环境变量导致运行失败。</p><p>以下为docker容器的解决方案</p><h2 id="解决方案">解决方案</h2><ol><li><p>保存容器环境变量(可以写在entrypoint中)</p><p>通过declare命令和grep命令捕获你所需要的环境变量至/container.env文件中(当然，这个文件你可以随意定义)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare -p | gerp -E &#x27;VAR1|VAR2|VAR2&#x27; &gt; /container.env</span><br></pre></td></tr></table></figure></li><li><p>运行时载入环境变量配置文件</p><p>有两种方式载入。</p><ol><li><p>通过需要执行的shell脚本载入，只需在shell脚本前加入即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取容器设定的环境变量</span></span><br><span class="line">source /container.env</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>直接在crontab中载入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL=/bin/bash</span><br><span class="line">BASH_ENV=/container.env</span><br><span class="line">* * * * * root /test-cron.sh</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="cron注意事项">cron注意事项</h2><p>不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量</p><ol><li>脚本中涉及文件路径时写全局路径(如python 通过which python 定位其全局路径再填入)</li><li>脚本执行其他环境变量时，通过source命令引入环境变量</li><li>当手动执行脚本OK，但是crontab执行失败时。很有可能环境变量出问题</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;​	因为&lt;em&gt;cron&lt;/em&gt;从非交互式、非登录 shell 运行作业。所以当&lt;a href=&quot;https://www.baeldung.com/cron-expressions&quot;&gt;&lt;em&gt;cron&lt;/em&gt;&lt;/a&gt;执行作业时，它</summary>
      
    
    
    
    <category term="Docker" scheme="https://blog.hellowei.ga/categories/Docker/"/>
    
    
    <category term="docker" scheme="https://blog.hellowei.ga/tags/docker/"/>
    
    <category term="cron" scheme="https://blog.hellowei.ga/tags/cron/"/>
    
    <category term="环境变量" scheme="https://blog.hellowei.ga/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(十五)-“数据结构”模式</title>
    <link href="https://blog.hellowei.ga/2021/11/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16/"/>
    <id>https://blog.hellowei.ga/2021/11/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16/</id>
    <published>2021-11-22T12:26:04.000Z</published>
    <updated>2022-08-16T13:34:42.498Z</updated>
    
    <content type="html"><![CDATA[<h1>“数据结构”模式</h1><p>常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。主要有以下三种</p><ol><li>Composite</li><li>Iterator</li><li>Chain of Resposibility</li></ol><h1>Composite</h1><h2 id="设计动机">设计动机</h2><ol><li>在软件在某些情况下，客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构(而非抽象接口)的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。</li><li>如何将“客户代码与复杂的对象容器结构&quot;解耦?让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器?</li></ol><h2 id="定义">定义</h2><blockquote><p>将对象组合成<strong>树形结构</strong>以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性(稳定)</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/16_01.png" alt="结构"></p><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Component</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span>:</span><span class="keyword">public</span> Component&#123;</span><br><span class="line">    string name;</span><br><span class="line">    list&lt;Component*&gt; elements; <span class="comment">//通常保存叶子结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Composite</span>(<span class="keyword">const</span> string&amp; s):<span class="built_in">name</span>(s)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component* element)</span></span>&#123;</span><br><span class="line">        elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component* element)</span></span>&#123;</span><br><span class="line">        elements.<span class="built_in">remove</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. 处理当前结点</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.处理叶子结点</span></span><br><span class="line">        <span class="comment">//多态调用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : elements)&#123;</span><br><span class="line">            e-&gt;<span class="built_in">process</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叶子结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span>:</span><span class="keyword">public</span> Component&#123;</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Leaf</span>(<span class="keyword">const</span> string&amp; s):<span class="built_in">name</span>(s)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="comment">//处理当前结点</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Invoke</span><span class="params">(Component&amp; c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将一对多转化为一对一的关系</span></span><br><span class="line">    c.<span class="built_in">process</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Composite <span class="title">root</span><span class="params">(<span class="string">&quot;root&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode1</span><span class="params">(<span class="string">&quot;treeNode1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode2</span><span class="params">(<span class="string">&quot;treeNode2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode3</span><span class="params">(<span class="string">&quot;treeNode3&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">leaf1</span><span class="params">(<span class="string">&quot;leaf1&quot;</span>)</span></span></span><br><span class="line"><span class="function">    Leaf <span class="title">leaf2</span><span class="params">(<span class="string">&quot;leaf2&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    root.<span class="title">add</span><span class="params">(&amp;treeNode1)</span></span>;</span><br><span class="line">    treeNode1.<span class="built_in">add</span>(&amp;treeNode2);</span><br><span class="line">    treeNode1.<span class="built_in">add</span>(&amp;treeNode3);</span><br><span class="line">    treeNode2.<span class="built_in">add</span>(&amp;leaf1);</span><br><span class="line">    treeNode3.<span class="built_in">add</span>(&amp;leaf2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Invoke处理一致性</span></span><br><span class="line">    <span class="built_in">Invoke</span>(root);</span><br><span class="line">    <span class="built_in">Invoke</span>(treeNode1);</span><br><span class="line">    <span class="built_in">Invoke</span>(leaf1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>Composite模式采用树形结构来实现普遍存在的对象容器，从而将‘一对多”的关系转化为“一对一”的关系，使得客户代码可以一致地(复用)处理对象和对象容器，无需关心处理的是单个的对象，还是组合的对象容器。</li><li>将“客户代码与复杂的对象容器结构”解耦是Composite的核心思想，解耦之后，客户代码将与纯粹的抽象接口一而非对象容器的内部实现结构一发生依赖，从而更能“应对变化”。</li><li>Composite模式在具体实现中，可以让父对象中的子对象反向追溯;如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。</li></ol><h1>Iterator</h1><h2 id="设计动机-2">设计动机</h2><ol><li>在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素;同时这种“透明遍历”也为“同一种算法在多种集合对象上进行操作’’提供了可能。</li><li>使用面向对象技术将这种遍历机制抽象为“迭代器对象”为“应对变化中的集合对象”提供了一种优雅的方式。</li></ol><h2 id="定义-2">定义</h2><blockquote><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露(稳定)该对象的内部表示。</p></blockquote><h2 id="结构-2">结构</h2><p><img src="/img/PatternDesign/16_02.png" alt="结构"></p><h2 id="总结-2">总结</h2><ol><li>在如今拥有STL和泛型编程的c++语言这种模式已被弃用(面对对象的迭代器性能损耗高),java,c#会用到</li><li>迭代抽象:访问一个聚合对象的内容而无需暴露它的内部表示。</li><li>迭代多态:为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构.上进行操作。</li><li>迭代器的健壮性考虑:遍历的同时更改迭代器所在的集合结构，会导致问题。</li></ol><h1>Chain of responsibility</h1><h2 id="设计动机-3">设计动机</h2><ol><li>在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接受者，如果显式指定，将必不可少地带来请求发送者与接受者的紧耦合。<br>2.如何使请求的发送者不需要指定具体的接受者?让请求的接受者自己在运行时决定来处理请求，从而使两者解耦。</li></ol><h2 id="定义-3">定义</h2><blockquote><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。</p></blockquote><h2 id="结构-3">结构</h2><p><img src="/img/PatternDesign/16_03.png" alt="结构"></p><h2 id="例子-2">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">RequestType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    REQ_HANDLER1,</span><br><span class="line">    REQ_HANDLER2,</span><br><span class="line">    REQ_HANDLER3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reqest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string description;</span><br><span class="line">    RequestType reqType;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Reqest</span>(<span class="keyword">const</span> string &amp; desc, RequestType type) : <span class="built_in">description</span>(desc), <span class="built_in">reqType</span>(type) &#123;&#125;</span><br><span class="line">    <span class="function">RequestType <span class="title">getReqType</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reqType; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> string&amp; <span class="title">getDescription</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> description; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChainHandler</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    ChainHandler *nextChain;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendReqestToNextHandler</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextChain != <span class="literal">nullptr</span>)</span><br><span class="line">            nextChain-&gt;<span class="built_in">handle</span>(req);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ChainHandler</span>() &#123; nextChain = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNextChain</span><span class="params">(ChainHandler *next)</span> </span>&#123; nextChain = next; &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">canHandleRequest</span>(req))</span><br><span class="line">            <span class="built_in">processRequest</span>(req);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">sendReqestToNextHandler</span>(req);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler1</span> :</span> <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.<span class="built_in">getReqType</span>() == RequestType::REQ_HANDLER1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler1 is handle reqest: &quot;</span> &lt;&lt; req.<span class="built_in">getDescription</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler2</span> :</span> <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.<span class="built_in">getReqType</span>() == RequestType::REQ_HANDLER2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler2 is handle reqest: &quot;</span> &lt;&lt; req.<span class="built_in">getDescription</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler3</span> :</span> <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.<span class="built_in">getReqType</span>() == RequestType::REQ_HANDLER3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler3 is handle reqest: &quot;</span> &lt;&lt; req.<span class="built_in">getDescription</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Handler1 h1;</span><br><span class="line">    Handler2 h2;</span><br><span class="line">    Handler3 h3;</span><br><span class="line">    h1.<span class="built_in">setNextChain</span>(&amp;h2);</span><br><span class="line">    h2.<span class="built_in">setNextChain</span>(&amp;h3);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Reqest <span class="title">req</span><span class="params">(<span class="string">&quot;process task ... &quot;</span>, RequestType::REQ_HANDLER3)</span></span>;</span><br><span class="line">    h1.<span class="built_in">handle</span>(req);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-3">总结</h2><ol><li>Chain of Responsibility模式的应用场合在于“一个请求可能有多个接受者，但是最后真正的接受者只有一个”，这时候请求发送者与接受者的耦合有可能出现“变化脆弱”的症状，职责链的目的就是将二者解耦，从而更好地应对变化。</li><li>应用了Chain of Responsibility模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加/修改请求的处理职责。</li><li>如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的责任，而不是发出请求的对象的责任。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;“数据结构”模式&lt;/h1&gt;
&lt;p&gt;常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。主要有以下三种&lt;/</summary>
      
    
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(十四)-Memento</title>
    <link href="https://blog.hellowei.ga/2021/11/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F15/"/>
    <id>https://blog.hellowei.ga/2021/11/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F15/</id>
    <published>2021-11-17T14:45:19.000Z</published>
    <updated>2022-08-16T13:34:42.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。</li><li>如何实现对象状态的良好保存与恢复?但同时又不会因此而破坏对象本身的封装性。</li></ol><h2 id="定义">定义</h2><blockquote><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/15_01.png" alt="结构"></p><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  状态快照</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memento</span>&#123;</span></span><br><span class="line">    string state;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Memento</span>(<span class="keyword">const</span> string&amp; s):<span class="built_in">state</span>(s)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">getState</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">        state = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Originator</span>&#123;</span></span><br><span class="line">    string state;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Originator</span>()&#123;&#125;</span><br><span class="line">    Memento createMemento&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Memento</span>(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        state = memento.<span class="built_in">getState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Originator originator;</span><br><span class="line">    <span class="comment">//捕获对象状态，存储快照</span></span><br><span class="line">    Memento m = originator.<span class="built_in">createMemento</span>();</span><br><span class="line">    <span class="comment">//恢复快照</span></span><br><span class="line">    originator.<span class="built_in">setMemento</span>(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>备忘录(Memento)存储原发器(Originator)对象的内部状态，在需要时恢复原发器状态。</li><li>Memento模式的核心是信息隐藏，即Originator需要向外接隐藏信息，保持其封装性。但同时又需要将状态保持到外界(Memento) 。</li><li>由于现代语言运行时（如C#、Java等）都具有相当的对象序列化支持，因此往往采用效率较高、又较容易正确实现的序列化方案来买现Memento模式。</li></ol><h2 id="状态变化-模式">&quot;状态变化&quot;模式</h2><blockquote><p>在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理?同时又维持高层模块的稳定?“状态变化&quot;模式为这一问题提供了一种解决方案。</p></blockquote><h3 id="典型模式">典型模式</h3><ol><li><a href="/2021/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/">State</a></li><li><a href="/2021/11/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F15/">Memento</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计动机&quot;&gt;设计动机&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。&lt;/li&gt;
&lt;li&gt;如何实现对象</summary>
      
    
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(十三)-State</title>
    <link href="https://blog.hellowei.ga/2021/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/"/>
    <id>https://blog.hellowei.ga/2021/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/</id>
    <published>2021-11-16T08:53:02.000Z</published>
    <updated>2022-08-16T13:34:42.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在软件构建过程中，某些对象的状态如果改变，其行为也会随之，而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。</li><li>如何在运行时根据对象的状态来透明地更改对象的行为?而不会为对象操作和状态转化之间引入紧耦合?</li></ol><h2 id="定义">定义</h2><blockquote><p>允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为。</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/14_01.png" alt="结构"></p><h2 id="例子">例子</h2><h3 id="传统">传统</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NetworkState</span>&#123;</span></span><br><span class="line">    NetworkOpen,</span><br><span class="line">    NetworkClose,</span><br><span class="line">    NetworkConnect,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkProcess</span>&#123;</span></span><br><span class="line">    NetworkState state;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state == NetworkOpen)&#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//state change</span></span><br><span class="line">            state  = NetworkClose;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == NetworkClose)&#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//state change</span></span><br><span class="line">            state  = NetworkConnect;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == NetworkConnect)&#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//state change</span></span><br><span class="line">            state  = NetworkOpen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state == NetworkOpen)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == NetworkClose)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            state  = NetworkConnect;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == NetworkConnect)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            state  = NetworkOpen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态模式">状态模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenState</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloseState</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectState</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkState</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NetworkState* pNext; <span class="comment">//next state</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供接口，等待子类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">NetworkState</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开启状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenState</span>:</span><span class="keyword">public</span> NetworkState&#123;</span><br><span class="line">    <span class="comment">//单例，只有一个状态实例</span></span><br><span class="line">    <span class="keyword">static</span> NetworkState* m_instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> NetworkState* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">OpenState</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="comment">//state change</span></span><br><span class="line">        pNext  = CloseState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloseState</span>:</span><span class="keyword">public</span> NetworkState&#123;</span><br><span class="line">    <span class="comment">//单例，只有一个状态实例</span></span><br><span class="line">    <span class="keyword">static</span> NetworkState* m_instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> NetworkState* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">CloseState</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="comment">//state change</span></span><br><span class="line">        pNext  = ConnectState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectState</span>:</span><span class="keyword">public</span> NetworkState&#123;</span><br><span class="line">    <span class="comment">//单例，只有一个状态实例</span></span><br><span class="line">    <span class="keyword">static</span> NetworkState* m_instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> NetworkState* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">ConnectState</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *******</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="comment">//state change</span></span><br><span class="line">        pNext  = OpenState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NetworkState* OpenState::m_instance = <span class="literal">nullptr</span>;</span><br><span class="line">NetworkState* CloseState::m_instance = <span class="literal">nullptr</span>;</span><br><span class="line">NetworkState* ConnectState::m_instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkProcessor</span>&#123;</span></span><br><span class="line">    NetworkState* pState;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">NetworkProcessor</span>(NetworkState* state):<span class="built_in">pState</span>(state)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        pState-&gt;<span class="built_in">operator1</span>();</span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态切换时，切换相应的对象;但同时维持State的接口，这样实现了具体操作与状态转换之间的解耦。</li><li>为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的——即要么彻底转换过来，要么不转换。</li><li>如果State对象没有实例变量，那么各个上下文可以共享同一个State对象，从而节省对象开销。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计动机&quot;&gt;设计动机&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在软件构建过程中，某些对象的状态如果改变，其行为也会随之，而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。&lt;/li&gt;
&lt;li&gt;如何在运行时根据对象的状态来透明地更改对象的行为?而不</summary>
      
    
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(十二)-Mediator</title>
    <link href="https://blog.hellowei.ga/2021/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13/"/>
    <id>https://blog.hellowei.ga/2021/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13/</id>
    <published>2021-11-15T02:07:12.000Z</published>
    <updated>2022-08-16T13:34:42.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。</li><li>在这种情况下，我们可使用一个“中介对象&quot;来管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系，从而更好地抵御变化。</li></ol><h2 id="定义">定义</h2><blockquote><p>用一个中介对象来封装(封装变化)一系列的对象交互。中介者使各对象不需要显式的相互引用(编译时依赖→运行时依赖)，从而使其耦合松散(管理变化)，而且可以独立地改变它们之间的交互。</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/13_01.png" alt="结构"></p><h2 id="总结">总结</h2><ol><li>将多个对象间复杂的关联关系解耦，Mediator模式将多个对象间的控制逻辑进行集中管理，变“多个对象互相关联&quot;为“多个对象和一个中介者关联”，简化了系统的维护，抵御了可能的变化。</li><li>随着控制逻辑的复杂化，Mediator具体对象的实现可能相当复杂。这时候可以对Mediator对象进行分解处理。</li><li>Façade模式是解耦系统间(单向)的对象关联关系;ediator模式是解耦系统内各个对象之间(双向)的关联关系。</li></ol><h2 id="接口隔离-模式">&quot;接口隔离&quot;模式</h2><blockquote><p>在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。</p></blockquote><h3 id="典型模式">典型模式</h3><ol><li><a href="/2021/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10/">Façade</a>    -解决系统内外的接口问题</li><li><a href="/2021/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/">Proxy</a>     -解决两对象之间的接口问题</li><li><a href="/2021/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/">Adapter</a>   -解决新老接口之间转换问题</li><li><a href="/2021/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13/">Mediator</a>  -解决多个对象复杂关联问题</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计动机&quot;&gt;设计动机&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。&lt;/li&gt;
&lt;li&gt;在这种情况下，我们可使用一个“中介对象&amp;</summary>
      
    
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(十一)-Adapter</title>
    <link href="https://blog.hellowei.ga/2021/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/"/>
    <id>https://blog.hellowei.ga/2021/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/</id>
    <published>2021-11-15T01:40:17.000Z</published>
    <updated>2022-08-16T13:34:42.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。</li><li>如何应对这种“迁移的变化&quot;?如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口?</li></ol><h2 id="定义">定义</h2><blockquote><p>将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/12_01.png" alt="结构"></p><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遗留接口(老接口)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IAdaptee</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遗留类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Oldclass</span> :</span> <span class="keyword">public</span> IAdaptee&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标接口(新接口)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ITarget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">porcess</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象适配器(继承＋组合)</span></span><br><span class="line"><span class="comment">//继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> :</span><span class="keyword">public</span> ITarget&#123; </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//组合</span></span><br><span class="line">    IAdaptee* pAdaptee;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Adapter</span>(IAdaptee* adaptee):<span class="built_in">pAdaptee</span>(adaptee)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">porcess</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用旧接口</span></span><br><span class="line">        <span class="built_in">foo</span>();</span><br><span class="line">        <span class="built_in">bar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类适配器 多继承(不推荐使用)</span></span><br><span class="line"><span class="comment">//缺乏灵活性，不是针对接口，定死在了Oldclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter1</span> :</span><span class="keyword">public</span> ITarget,<span class="keyword">protected</span> Oldclass&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IAdaptee* pAdaptee = <span class="keyword">new</span> <span class="built_in">Oldclass</span>();</span><br><span class="line">    ITarget* pTarget = <span class="keyword">new</span> <span class="built_in">Adapter</span>(pAdaptee);</span><br><span class="line">    pTarget-&gt;<span class="built_in">process</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li><p>Adapter模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。</p></li><li><p>-GoF 23定义了两种Adapter模式的实现结构:对象适配器和类适配器。但类适配器采用“多继承&quot;的实现方式，一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神。</p></li><li><p>Adapter模式可以实现的非常灵活，不必拘泥于Gof23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象&quot;作为新的接口方法参数，来达到适配的目的。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计动机&quot;&gt;设计动机&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。&lt;/li&gt;
&lt;li&gt;如何应对这种“迁移的变化&amp;quot;?如何既能利用现有对象的良好实</summary>
      
    
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(十)-Proxy</title>
    <link href="https://blog.hellowei.ga/2021/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/"/>
    <id>https://blog.hellowei.ga/2021/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/</id>
    <published>2021-11-10T12:50:26.000Z</published>
    <updated>2022-08-16T13:34:42.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在面向对象系统中，有些对象由于某种原因(比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等)直接访问会给使用者、或者系统结构带来很多麻烦。</li><li>如何在不失去透明操作对象的同时来管理/控制这些对象特有的复<br>杂性?增加一层间接层是软件开发中常见的解决方式。</li></ol><h2 id="定义">定义</h2><blockquote><p>为其他对象提供一种代理以控制(隔离，使用接口)对这个对象的访问</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/11_01.png" alt="结构"></p><h2 id="例子">例子</h2><h3 id="传统">传统</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISubject</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span>:</span> <span class="keyword">public</span> ISubject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientApp</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    ISubject* subject;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">ClientApp</span>()&#123;</span><br><span class="line">        subject=<span class="keyword">new</span> <span class="built_in">RealSubject</span>();</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        subject-&gt;<span class="built_in">process</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="代理模式">代理模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISubject</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Proxy的设计</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span>:</span> <span class="keyword">public</span> ISubject&#123;  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//对RealSubject的一种间接访问</span></span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientApp</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    ISubject* subject;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">ClientApp</span>()&#123;</span><br><span class="line">        subject=<span class="keyword">new</span> <span class="built_in">SubjectProxy</span>();</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        subject-&gt;<span class="built_in">process</span>();      </span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>“增加一层间接层’是软件系统中对许多复杂问题的一种常见解决方法。在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的proxy对象便是解决这一问题的常用手段。</li><li>具体proxy设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如copy-on-write技术， 有些可能对组件模块提供抽象代理层,在架构层次对对象做proxy。</li><li>Proxy并不一定要求保持接口完整的一致性，只要能够实现间接控<br>制，有时候损及一些透明性是可以接受的。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计动机&quot;&gt;设计动机&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在面向对象系统中，有些对象由于某种原因(比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等)直接访问会给使用者、或者系统结构带来很多麻烦。&lt;/li&gt;
&lt;li&gt;如何在不失去透明操作对象的同时来管</summary>
      
    
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(九)-Façade</title>
    <link href="https://blog.hellowei.ga/2021/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10/"/>
    <id>https://blog.hellowei.ga/2021/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10/</id>
    <published>2021-11-10T10:36:00.000Z</published>
    <updated>2022-08-16T13:34:42.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><p><img src="/img/PatternDesign/10_01.png" alt="动机"></p><ol><li>上述A方案的问题在于组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。</li><li>如何简化外部客户程序和系统间的交互接口?如何将外部客户程<br>序的演化和内部子系统的变化之间的依赖相互解耦?</li></ol><h2 id="定义">定义</h2><blockquote><p>为子系统中的一-组接口提供一个**一致(稳定)**的界面,Façade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用(复用)</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/10_02.png" alt="结构"></p><h2 id="总结">总结</h2><ol><li>从客户程序的角度来看，Façade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种“解耦”的效果，内部子系统的任何变化不会影响到Façade接口的变化。</li><li>Façade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Façade很多时候更是一种架构设计模式。</li><li>Façade设计模式并非一个集装箱，可以任意地放进任何多个对象。Façade模式中组件的内部应该是“相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计动机&quot;&gt;设计动机&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/img/PatternDesign/10_01.png&quot; alt=&quot;动机&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上述A方案的问题在于组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演</summary>
      
    
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(八)-Flyweight</title>
    <link href="https://blog.hellowei.ga/2021/11/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F09/"/>
    <id>https://blog.hellowei.ga/2021/11/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F09/</id>
    <published>2021-11-08T02:39:41.000Z</published>
    <updated>2022-08-16T13:34:42.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价——主要指内存需求方面的代价。</li><li>在避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作</li></ol><h2 id="定义">定义</h2><blockquote><p>运用共享技术有效地支持大量细粒度的对象</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/09_01.png" alt="结构"></p><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//unique object key</span></span><br><span class="line">    string key;  </span><br><span class="line">    <span class="comment">//object state</span></span><br><span class="line">    <span class="comment">//....   </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Font</span>(<span class="keyword">const</span> string&amp; key)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FontFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;string,Font* &gt; fontPool;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Font* <span class="title">GetFont</span><span class="params">(<span class="keyword">const</span> string&amp; key)</span></span>&#123;</span><br><span class="line">        map&lt;string,Font*&gt;::iterator item=fontPool.<span class="built_in">find</span>(key);       </span><br><span class="line">        <span class="keyword">if</span>(item!=footPool.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> fontPool[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Font* font = <span class="keyword">new</span> <span class="built_in">Font</span>(key);</span><br><span class="line">            fontPool[key]= font;</span><br><span class="line">            <span class="keyword">return</span> font;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>面向对象很好地解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。</li><li>Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。</li><li>对象的数量太大从而导致对象内存开销加大——什么样的数量才算大?这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断。</li></ol><p><img src="/img/PatternDesign/PatternDesign09.png" alt="PatternDesign09"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计动机&quot;&gt;设计动机&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价——主要指内存需求方面的代价。&lt;/li&gt;
&lt;li&gt;在避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向</summary>
      
    
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(七)- Singleton</title>
    <link href="https://blog.hellowei.ga/2021/11/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F08/"/>
    <id>https://blog.hellowei.ga/2021/11/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F08/</id>
    <published>2021-11-07T14:54:33.000Z</published>
    <updated>2022-08-16T13:34:42.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。</li><li>绕过常规的构造器，提供一种机制来保证一个类只有一个实例</li><li>这是类设计者的责任，而不是使用者的责任。</li></ol><h2 id="定义">定义</h2><blockquote><p>保证一个类仅有一个实例，并提供一个该实例的全局访问点。</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/08_01.png" alt="结构"></p><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//单例模式只能有一个示例 因此需要阻止拷贝</span></span><br><span class="line">    <span class="comment">//拷贝构造函数、拷贝赋值运算符不需要</span></span><br><span class="line">    <span class="comment">//新标准加上delete可以定义为删除或定义为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态变量初始化</span></span><br><span class="line">Singleton* Singleton::m_instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程非安全版本</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程安全版,但锁的代价过高</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="keyword">if</span>(m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双检查锁 ，但由于内存读写reorder不安全</span></span><br><span class="line"><span class="comment">//只有为空才加锁，锁前不检查代价过高，锁后不检查线程不安全</span></span><br><span class="line"><span class="comment">//不要再用了</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Lock lock;</span><br><span class="line">        <span class="keyword">if</span>(m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c++11 版本之后的跨平台实现</span></span><br><span class="line">std::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class="line">std::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);<span class="comment">//获取内存fence</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);<span class="comment">//释放内存fence</span></span><br><span class="line">            m_instance.<span class="built_in">store</span>(tmp, std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用局部静态变量实现简洁的singleton写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//单例模式只能有一个示例 因此需要阻止拷贝</span></span><br><span class="line">    <span class="comment">//拷贝构造函数、拷贝赋值运算符不需要</span></span><br><span class="line">    <span class="comment">//新标准加上delete可以定义为删除或定义为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function">Singleton&amp; <span class="title">operator</span><span class="params">(<span class="keyword">const</span> Singleton&amp;)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton m_instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单线程下，正确。</li><li>C++11及以后的版本（如C++14）的多线程下，正确。</li><li>C++11之前的多线程下，不一定正确。原因在于在C++11之前的标准中并没有规定local static变量的内存模型。于是乎它就是不是线程安全的了。但是在C++11却是线程安全的，这是因为新的C++标准规定了当一个线程正在初始化一个变量的时候，其他线程必须得等到该初始化完成以后才能访问它。</li></ul><p>上述使用的内存序：</p><p>memory_order_relaxed：松散内存序，只用来保证对原子对象的操作是原子的<br>memory_order_acquire：获得操作，在读取某原子对象时，当前线程的任何后面的读写操作都不允许重排到这个操作的前面去，并且其他线程在对同一个原子对象释放之前的所有内存写入都在当前线程可见<br>memory_order_release：释放操作，在写入某原子对象时，当前线程的任何前面的读写操作都不允许重排到这个操作的后面去，并且当前线程的所有内存写入都在对同一个原子对象进行获取的其他线程可见</p><h2 id="总结">总结</h2><ol><li>Singleton模式中的实例构造器可以设置为protected以允许子类派生。</li><li>Singleton模式一般不要支持拷贝构造函数和Clone接口，因为这有可能导致多个对象实例，与Singleton模式的初衷违背。</li><li>如何实现多线程环境下安全的Singleton?注意对双检查锁的正确实现。</li></ol><p><img src="/img/PatternDesign/PatternDesign08.png" alt="PatternDesign08"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计动机&quot;&gt;设计动机&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。&lt;/li&gt;
&lt;li&gt;绕过常规的构造器，提供一种机制来保证一个类只有一个实例&lt;/li&gt;
&lt;li&gt;这是</summary>
      
    
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(六)- Factory</title>
    <link href="https://blog.hellowei.ga/2021/11/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F07/"/>
    <id>https://blog.hellowei.ga/2021/11/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F07/</id>
    <published>2021-11-07T11:28:09.000Z</published>
    <updated>2022-08-16T13:34:42.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>在软件系统中,经常面临着创建对象的工作;由于需求的变化,需要创建的对象的具体类型经常变化</li><li>如何应对这种变化?如何绕过常规的对象创建方法(new)，提供一种“封装机制&quot;来避免客户程序和这种“具体对象创建工作&quot;的紧耦合?</li></ol><h2 id="定义">定义</h2><blockquote><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化<strong>延迟</strong>(目的:解耦，手段︰虚函数)到子类。</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/07_01.png" alt="结构"></p><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//product抽象类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ISplitter</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Creator工厂基类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplitterFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">SplitterFactory</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">    SplitterFactory*  factory;<span class="comment">//工厂</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainForm</span>(SplitterFactory*  factory)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;factory=factory;</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;   </span><br><span class="line">ISplitter * splitter=</span><br><span class="line">            factory-&gt;<span class="built_in">CreateSplitter</span>(); <span class="comment">//多态new    </span></span><br><span class="line">        splitter-&gt;<span class="built_in">split</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在完成产品类和对应的工厂类后，便可在<code>MainForm</code>中应用。可以保证编译时只依赖与产品基类和工厂单类。子类可以依据需求随时实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类的实现</span></span><br><span class="line"><span class="comment">//具体product</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span> :</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//具体工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BinarySplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TxtSplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。</li><li>Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改)的策略，较好地解决了这种紧耦合关系。</li><li>Factory Method模式解决“单个对象&quot;的需求变化。缺点在于要求创建方法/参数相同。</li></ol><p><img src="/img/PatternDesign/PatternDesign07.png" alt="PatternDesign07"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计动机&quot;&gt;设计动机&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在软件系统中,经常面临着创建对象的工作;由于需求的变化,需要创建的对象的具体类型经常变化&lt;/li&gt;
&lt;li&gt;如何应对这种变化?如何绕过常规的对象创建方法(new)，提供一种“封装机制&amp;quot;来避免客户程序和这种</summary>
      
    
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(五)- Birdge</title>
    <link href="https://blog.hellowei.ga/2021/11/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F06/"/>
    <id>https://blog.hellowei.ga/2021/11/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F06/</id>
    <published>2021-11-04T07:54:02.000Z</published>
    <updated>2022-08-16T13:34:42.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计动机">设计动机</h2><ol><li>由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个纬度的变化</li><li>如何应对这种“多维度的变化”?如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度?</li></ol><h2 id="定义">定义</h2><blockquote><p>将抽象部分业务功能)与实现部分(平台实现)分离，使它们都可以独立地变化。</p></blockquote><h2 id="结构">结构</h2><p><img src="/img/PatternDesign/06_01.png" alt="结构"></p><h2 id="例子">例子</h2><h3 id="传统继承">传统继承</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Messager</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Messager</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//平台实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerBase</span> :</span> <span class="keyword">public</span> Messager&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerBase</span> :</span> <span class="keyword">public</span> Messager&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务抽象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerLite</span> :</span> <span class="keyword">public</span> PCMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerPerfect</span> :</span> <span class="keyword">public</span> PCMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerLite</span> :</span> <span class="keyword">public</span> MobileMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerPerfect</span> :</span> <span class="keyword">public</span> MobileMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//编译时装配</span></span><br><span class="line">        Messager *m =</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">MobileMessagerPerfect</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="桥模式">桥模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Messager</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">     MessagerImp* messagerImp;<span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Messager</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerImp</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">MessagerImp</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//平台实现 n</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerImp</span> :</span> <span class="keyword">public</span> MessagerImp&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerImp</span> :</span> <span class="keyword">public</span> MessagerImp&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//业务抽象 m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类的数目：1+n+m</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerLite</span> :</span><span class="keyword">public</span> Messager &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerPerfect</span>  :</span><span class="keyword">public</span> Messager &#123;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    MessagerImp* mImp=<span class="keyword">new</span> <span class="built_in">PCMessagerImp</span>();</span><br><span class="line">    Messager *m =<span class="keyword">new</span> <span class="built_in">Messager</span>(mImp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。</li><li>Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单职责原则(即一个类只有一个变化的原因)，复用性比较差。Bridge模式是比多继承方案更好的解决方法。</li><li>Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。</li></ol><p><img src="/img/PatternDesign/PatternDesign06.png" alt="PatternDesign06"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计动机&quot;&gt;设计动机&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个纬度的变化&lt;/li&gt;
&lt;li&gt;如何应对这种“多维度的变化”?如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度?</summary>
      
    
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://blog.hellowei.ga/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
